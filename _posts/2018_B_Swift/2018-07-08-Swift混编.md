---
layout: post
title: "Swift混编"
date: 2018-07-08
description: ""
tag: Swift
---

-[从预编译的角度理解Swift与Objective-C及混编机制](https://tech.meituan.com/2021/02/25/swift-objective-c.html)

## 目录
* [预编译知识指北](#content1)
* [PCH(PreCompiled Header)是一把双刃剑](#content2)
* [Clang Module 的来临！](#content3)
* 
* [XCFramework内三个文件](#content8)



## <a id="content1">预编译知识指北</a>

#include 是对头文件的简单复制       
#import 也是对头文件的复制，但保证不会重复粘贴        
在预编译阶段会对#import引入的头文件进行替换（递归替换）       


这种引入方式存在的问题：  

最主要的问题是：    
<span style="color:red;font-weight:bold;">会被重复复制和重复编译</span>    

另外还有：

**一、健壮性**     
比如定义了宏定义 #define readonly 0x01,会导致编译器报错    

**二、拓展性**   
在其它文件都要引用的文件中添加了一个 iAd.h 文件的引用，这意味着其他文件也会把 iAd.h里包含的东西纳入进来    
M个源文件，每个文件引入N个头文件，那么编译他们的时间就是M*N    




## <a id="content2">PCH(PreCompiled Header)是一把双刃剑</a>

将pch里的内容进行预编译，变成中间格式的二进制代码，在.m文件编译时直接读取，无需再次编译      
这样pch文件内引用的头文件只需要编译一次不会被重复编译      

存在的问题：   
PCH引入的头文件会出现在代码的任何地方，造成冗余       



## <a id="content3">Clang Module 的来临！</a>

#### **一、有什么好处**    
1、只会编译一次，避免重复编译          
2、按需引入，不会像pch那样的全量引入       
3、独立空间，不会被上下文篡改，比如前面提到的 #define readonly 0x01   

#### **二、modulemap文件介绍**  

-[参考文章：理解 Clang Module 和 Module Map 语法](https://juejin.cn/post/7195394554760003644)   
  
**framework module XXXX** 定义了一个 framework 语义的模块       
**umbrella header "XXXX.h"** 说明把 XXXX.h 文件作为模块的 unbrella header，伞头文件相当于模块中所有公共头文件的一个集合，方便使用者导入。      
<span style="font-weight:bold;">export *</span>  将所有子模块中的符号进行重导出到主模块中        
**module * { export * }** 定义子模块，这里为 * 则是为 umbrella header 中的每个头文件都创建一个子模块。   


```text
module LCCat {
    header "Cat.h"  // 导出Cat.h头文件
    export *   // 导出Cat.h文件内引用的所有头文件
    
    // 子模块 Sub
    module Sub {
        header "sub.h"
        export *
    }
    
    //使用时只能显示导入：@import LCCat.InternalModule
    explicit module InternalModule {
        header "InternalHeader.h"
        export *
    }
}
```

```text
// framework 代表这是一个库
framework module SwiftFramwork {

  //umbrella 伞文件，统一管理头文件
  //header 去framework下的header目录里查找
  umbrella header "SwiftFramwork.h"
  export *  // 导出伞文件内引用的所有头文件

  //为伞文件内的所有头文件创建一个子模块
  module * { export * }
}
```

#### **三、编译选项介绍**    

**1、要想在Swift库中生成xxx-swift.h文件供OC代码使用需要打开：**    

<img src="/images/swift/swift_1.png">

打开之后会在modulemap文件内自动生成 SwiftFramwork.Swift 子模块    
```text
framework module SwiftFramwork {
  umbrella header "SwiftFramwork.h"
  export *
  
  module * { export * }
}

module SwiftFramwork.Swift {
  header "SwiftFramwork-Swift.h"
  requires objc // 表示该模块仅在 Objective-C 环境中可用
}
```

**2、为什么我从来没看到过 @import 的写法呢?**      
这是因为 Xcode 的编译器能够将符合某种格式的 #import 语句自动转换成 Module 识别的 @import 语句，从而避免了开发者的手动修改。    
唯一需要开发者完成的就是开启相关的编译选项。  

**Enable Module** 选项是指引用系统库的的时候，是否采用 Module 的形式          
**Defines Module** 是指开发者编写的组件是否采用 Module 的形式开启后会生成 *.modulemap文件   

**3、使用自定义的.modulemap文件**    

注意是相对路径   
<img src="/images/swift/swift_2.png">

<span style="color:red;font-weight:bold;">提示：</span>

lxy：    
目前看到的上边的编译选项都是针对系统库和自定义的组件库的，不知道是否理解错误     
Defines Module在工程的target下开启并没有反应，也不知道生成的modulemap文件在哪里        
在工程的target下配置自定义modulemap文件，在工程中的.m文件通过module的方式引用也不生效         



## <a id="content8">XCFramework内三个文件</a>

**.swiftmodule：**     
包含序列化过的 AST（抽象语法树，Abstract Syntax Tree)    
也包含 SIL (Swift 中间语言，Swift Intermediate Language)    

**.swiftdoc：**   
用户文档

**.swiftinterface:**    
Module stability



----------
>  行者常至，为者常成！
