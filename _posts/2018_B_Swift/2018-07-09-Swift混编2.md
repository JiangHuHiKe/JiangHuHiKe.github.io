---
layout: post
title: "Swift混编2"
date: 2018-07-09
description: ""
tag: Swift
---

-[参考文章1：从预编译的角度理解Swift与Objective-C及混编机制](https://tech.meituan.com/2021/02/25/swift-objective-c.html)

## 目录

* [在同一个target内的互相调用](#content1)
* [在不同的target内的互相调用](#content2)


## <a id="content1">在同一个target内的互相调用</a>

我们知道，每个文件的编译是独立的。<span style="color:red;">能够互相调用，就是在编译阶段能够找到对方声明的接口。</span>

#### **一、在 App target 内的互相调用**   

我们创建一个Object-C的工程：InvocationDemo

**1、OC调用OC**      
通过头文件来知道对方的声明接口      

**2、OC调用Swift**    
在 App target 中如果有OC和swift的代码混编，编译时会生成一个ProjectName-swift.h的文件    
<span style="font-size:12; font-style:italic;color:grey;">提示：要了解ProjectName-swift.h文件是如何生成的，在参考文章1中有讲述</span>
```text
// swift中被@objc修饰的类和方法，会以OC声明的方式放在这个文件
InvocationDemo-Swift.h

// oc调用swift时只需要引用这个头文件就可以
#import "InvocationDemo-Swift.h"
```
这个头文件是编译器过程中自动生成的不需要手动生成，如果需要手动添加，该文件的位置如下：
```text
// xx.noindex是存放中间代码的  
/Users/YourUsername/Library/Developer/Xcode/DerivedData/YourProjectName-*/Build/Intermediates.noindex
/YourLibraryName.build/Debug-iphoneos/YourLibraryName.build/Objects-normal/arm64/YourLibraryName-Swift.h
```
InvocationDemo-Swift.h就是声明的接口文件       

**3、Swift调用OC**    
在 InvocatoionDemo 这个 App target 中创建一个SwiftViewController.swift文件，系统会提示创建一个桥接头文件       
<span style="color:grey;font-size:12; font-style:italic;">提示：如果工程是swift工程，那么在创建Object-C文件时同样会提示创建桥接头文件</span>          
```text
// swift调用oc需要用到这个文件
InvocationDemo-Bridging-Header.h

// 将OC代码的头文件放到这个文件内，swift代码就可以调用oc代码了
#import "OCPerson.h"
```

InvocationDemo-Bridging-Header.h 就是声明的接口文件    

**4、Swift 调用 Swift**   

**(1)在参考文章1的 第一步 - 如何寻找 Target 内部的 Swift 方法声明 章节有说明**    

Swift没有头文件，意味着，编译器会进行额外的操作来查找接口定义并需要持续关注接口的变化！    

Swiftc 编译的时候，会将相同 Target 里的其他 Swift 文件进行一次解析，用来检查其中与被编译文件关联的接口部分是否符合预期。

每编译一个文件，就需要将当前 Target 里的其余文件当做接口



**(2)添加了swift文件后，在编译产物中会看到多出了一个InvocationDemo.swiftmodule文件**    
```text
// Swift没有头文件，这个文件的作用是提供 Swift 模块的接口描述，用于swift模块之间(不是模块内部)的互相调用  
InvocationDemo.swiftmodule
```
InvocationDemo-Swift.h文件是在InvocationDemo.swiftmodule文件的基础上生成的。     
也就是说先有swiftmodule文件再有-swift.h文件        

<span style="color:grey;font-size:12;font-style:italic;">xy:在target内部，swift之间的相互调用不是通过InvocationDemo.swiftmodule文件找到对方的。swiftmodule文件是在编译完每个swift文件之后生成的，这在参考文章1中有相关的说明。下面的编译顺序也能说明这个问题</span>
<img src="/images/swift/swift_5.png">


<span style="color:red;font-weight:bold;">在 app target 内总结</span>     
(1)Swift调用OC：InvocationDemo-Bridging-Header.h 添加swift文件时会提示创建        
(2)OC调用Swift：InvocationDemo-Swift.h 该文件是编译过程中自动生成的不需要手动创建          
(3)OC调用OC：头文件     
(4)Swift调用Swift：被编译swift文件将其它swift文件当做接口文件     
当我们创建一个Swift工程时，在工程内进行混编也是一样的道理。    



#### **二、在 library 内的互相调用**

library 内允许创建 OCLibrary-Bridging-Header.h 桥接头文件,所以 library 内 OC 和 Swift 代码的调用,跟在 App target 内并无区别

(1)Swift调用OC：InvocationDemo-Bridging-Header.h 添加swift文件时会提示创建        
(2)OC调用Swift：InvocationDemo-Swift.h 该文件是编译过程中自动生成的不需要手动创建          
(3)OC调用OC：头文件     
(4)Swift调用Swift：被编译swift文件将其它swift文件当做接口文件

同样在编译产物里也能看到<span style="color:red;font-weight:bold;">OCLibrary.swiftmodule</span> 文件 


#### **三、在 framework 内的互相调用**

(1)Swift调用OC：不同于上面两种情形     
(2)OC调用Swift：InvocationDemo-Swift.h 该文件是编译过程中自动生成的不需要手动创建          
(3)OC调用OC：头文件     
(4)Swift调用Swift：被编译swift文件将其它swift文件当做接口文件

不管是动态还是静态framework，我们在添加swift文件时不会再提示创建 Projectname-Bridging-Header.h文件(framework内不允许使用桥接头文件)              

**那么我们Swift代码如何调用OC代码呢？**     

framework在构建时会生成modulemap文件，我们将OC的头文件放在modulemap里，就可以被swift引用到     
<span style="font-size:12; font-style:italic; color:grey;">提示：在参考文章1中 第二步 - 如何找到 Objective-C 组件里的方法声明 章节里有说明：Swift 编译器将 Clang 的大部分功能包含在其自身的代码中，这就使得我们能够以 Module 的形式，直接引用 Objective-C 的代码</span>

我们查看产物里的modulemap发现SwiftFramework.h文件是modulemap文件的伞文件
```text
framework module SwiftFramework {
  umbrella header "SwiftFramework.h"
  export *

  module * { export * }
}

module SwiftFramework.Swift {
  header "SwiftFramework-Swift.h"
  requires objc
}
```

所以我们将oc的头文件放在伞文件下就可以了    
```text
#import <Foundation/Foundation.h>

//! Project version number for SwiftFramework.
FOUNDATION_EXPORT double SwiftFrameworkVersionNumber;

//! Project version string for SwiftFramework.
FOUNDATION_EXPORT const unsigned char SwiftFrameworkVersionString[];

// In this header, you should import all the public headers of your framework using statements like #import <SwiftFramework/PublicHeader.h>


// 需要用这种方式
#import <SwiftFramework/SwiftFrameOCPerson.h>

```


## <a id="content2">在不同的target内的互相调用</a>

#### **一、App target 使用 framework**    

**1、app target 中的 swift 代码 调用 framework中的 swift 代码**   

能调用的关键是framework库中的SwiftFramework.swiftmodule文件

在 app target -> build phases -> link binary with libraries 中，正确添加framework     
<span style="color:red;font-size:12;font-style:italic">注意：如果是动态framework，需要embed，否则在启动的时候无法加载动态库</span>

在 app target 的 swift 代码中添加自定义模块的引用    
<span style="color:grey;font-size:12;font-style:italic">说明：swift中 import 的作用是引入其它模块</span>

```text
import SwiftFramework
```

接下来就可以调用framework内的swift代码了    
<span style="color:red;font-size:12;font-style:italic">注意： SwiftFrameViewController 类需要是 public 否则不会暴露给其它模块</span>

```text
    @objc
    func jumpHandle(button:UIButton){
        let vc = SwiftFrameViewController()
        self.navigationController?.pushViewController(vc, animated: true)
    }
```

**2、app target 中的 oc 代码 调用 framework中的 swift 代码**

（1）oc代码调用swift代码，需要SwiftFramework-Swift.h文件         
（2）SwiftFramework不会自动生成SwiftFramework-Swift.h文件，需要在<span style="color:red;"> Build Settings -> Install Generated Header </span>的开关打开，打开后在产物里才会有这个文件   
<span style="color:red;">（3）被oc调用的swift代码需要添加@objc标识，只有添加了@objc标识的代码的生命才会出现在SwiftFramework-Swift.h里</span>    
```text
import UIKit

@objc
public class SwiftFrameViewController: UIViewController {
    public override func viewDidLoad() {
        super.viewDidLoad()
        self.title = "SwiftFrameViewController"
    }
}
```

在 app target 的 oc 代码中调用  
```text
#import <SwiftFramework/SwiftFramework-Swift.h>

...

-(void)jumpHandle:(UIButton*)jumpBtn {
    UIViewController * vc = [[SwiftFrameViewController alloc] init];
    [self.navigationController pushViewController:vc animated:YES];
}
```

**3、app target 中的 swift 代码 调用 framework中的 oc 代码**    
为了能在外部访问，我们将 SwiftFramework 中的 SwiftFrameOCViewController.h 头文件 拖入到 Build Phases -> Headers -> public     
这时候编译会报错：   
<img src="/images/swift/swift_4.png">
<span style="font-style:italic;font-size:12;color:grey;">xy:我们在 app target 中使用 framework时，会优先通过modulemap来寻找头文件的信息，所以暴露给外部的头文件需要添加到伞文件，信息才会被modulemap管理。从这一方面看苹果也是在主推modulemap</span>

我们知道framework的伞文件就是 SwiftFramework.h, 所以将SwiftFrameOCViewController.h文件添加到该文件中   
```text
#import <Foundation/Foundation.h>

//! Project version number for SwiftFramework.
FOUNDATION_EXPORT double SwiftFrameworkVersionNumber;

//! Project version string for SwiftFramework.
FOUNDATION_EXPORT const unsigned char SwiftFrameworkVersionString[];

#import <SwiftFramework/SwiftFrameOCViewController.h>
```

在 app target 中的 swift 代码中调用
```text
import SwiftFramework

...

@objc
func jumpHandle(button:UIButton){
    let vc = SwiftFrameOCViewController()
    self.navigationController?.pushViewController(vc, animated: true)
}
```

<span style="font-style:italic;font-size:12;color:grey;">xy:我们手动将SwiftFramework中的module.modulemap文件移走，app target照样能正常运行，所以起作用的还是SwiftFramework.swiftmodule.猜测SwiftFramework在编译过程中将SwiftFrameOCViewController.h头文件信息以某种方式打包进了SwiftFramework.swiftmodule文件内</span>

**根据前面的相关讲解，我们其实还有一种方式让 app target 中的 swift 代码 调用到 framework中的 oc 代码**

将#import <SwiftFramework/SwiftFrameOCViewController.h>放在 app target 内的 桥接头文件内
```text
// app target 的 桥接头文件
InvocationDemo-Bridging-Header.h

内容如下：
<SwiftFramework/SwiftFrameOCViewController.h>
```
这样app target 中的 swift 代码 不需要import模块就可以直接调用  
```text
@objc
func jumpHandle(button:UIButton){
    let vc = SwiftFrameOCViewController()
    self.navigationController?.pushViewController(vc, animated: true)
}
```

**4、app target 中的 oc 代码 调用 framework中的 oc 代码**

(1)通过传统方式引入
```text
#import <SwiftFramework/SwiftFrameOCViewController.h>

...

-(void)jumpHandle:(UIButton*)jumpBtn {
    SwiftFrameOCViewController * vc = [[SwiftFrameOCViewController alloc] init];
    [self.navigationController pushViewController:vc animated:YES];
}
```

(2)通过module方式引入

```text
// 引入整个模块
//@import SwiftFramework;

// 只引入需要的子模块
@import SwiftFramework.SwiftFrameOCViewController;


...

-(void)jumpHandle:(UIButton*)jumpBtn {
    SwiftFrameOCViewController * vc = [[SwiftFrameOCViewController alloc] init];
    [self.navigationController pushViewController:vc animated:YES];
}
```
(3)做个小实验  
我们手动将SwiftFramework中的module.modulemap文件移走，会发现 @import SwiftFramework; 的这种方式会报错：    
Module 'SwiftFramework' not found        
所以模块引入是依赖module.modulemap的     

另外从文章顶部列出的参考文章中我们得知：#import <SwiftFramework/SwiftFrameOCViewController.h> 这种方式编译器会帮我们转为 @import SwiftFramework 的方式     
优先从module中寻找头文件信息，只有找不到时才会去搜索头文件      




**oc代码**    
1、使用oc代码（头文件、modulemap）

2、使用swift代码(-swift.h文件、modulemap可以也是因为子模块包含了-swift.h文件)    
-swift.h头文件没有被放到目录时，可以在下面存放中间产物的目录内找到
```text
/Users/YourUsername/Library/Developer/Xcode/DerivedData/YourProjectName-*/Build/Intermediates.noindex/YourLibraryName.build/Debug-iphoneos/YourLibraryName.build/Objects-normal/arm64/YourLibraryName-Swift.h
```


**swift代码**        
1、使用oc代码(需要把oc头文件放在swift代码所在 target 的 bridging-header.h文件内)       
2、使用oc代码(framework内不允许使用bridging-header.h,将oc头文件放在modulemap的伞文件内)              
3、使用swift代码(swiftmodule，不管是静态动态framework还是.a库只要包含swift代码都会有swiftmodule文件生成)    





----------
>  行者常至，为者常成！
