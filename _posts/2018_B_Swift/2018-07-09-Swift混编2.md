---
layout: post
title: "Swift混编2"
date: 2018-07-09
description: ""
tag: Swift
---

-[从预编译的角度理解Swift与Objective-C及混编机制](https://tech.meituan.com/2021/02/25/swift-objective-c.html)

## 目录

* [在同一个target内的互相调用](#content1)
* [在不同的target内的互相调用](#content2)


## <a id="content1">在同一个target内的互相调用</a>

#### **一、在 App target 内的互相调用**   

我们创建一个Object-C的工程：InvocationDemo

**1、OC调用OC**      
这个就不用再说明了    


**2、OC调用Swift**    
在 App target 中如果有OC和swift的代码混编，编译时会生成一个ProjectName-swift.h的文件
```text
// swift中被@objc修饰的类和方法，会以OC声明的方式放在这个文件
InvocationDemo-Swift.h

// oc调用swift时只需要引用这个头文件就可以
#import "InvocationDemo-Swift.h"
```
这个头文件是编译器过程中自动生成的不需要手动生成，该文件的位置如下：
```text
// xx.noindex是存放中间代码的  
/Users/YourUsername/Library/Developer/Xcode/DerivedData/YourProjectName-*/Build/Intermediates.noindex
/YourLibraryName.build/Debug-iphoneos/YourLibraryName.build/Objects-normal/arm64/YourLibraryName-Swift.h
```


**3、Swift调用OC**    
在 InvocatoionDemo 这个 App target 中创建一个SwiftViewController.swift文件，系统会提示创建一个桥接头文件    

```text
// swift调用oc需要用到这个文件
InvocationDemo-Bridging-Header.h

// 将OC代码的头文件放到这个文件内，swift代码就可以调用oc代码了
#import "OCPerson.h"
```

**4、Swift 调用 Swift**   
添加了swift文件后，在编译产物中会看到多出了一个InvocationDemo.swiftmodule文件    
```text
// Swift没有头文件，这个文件的作用是提供 Swift 模块的接口描述，用于swift之间的互相调用  
// 有了这个文件后，swift 之间的互相调用不要import就可以实现
// lxy:swift的modulemap文件。我觉得放入桥接文件的头文件最终也会被打包进这个文件
InvocationDemo.swiftmodule
```
 
<span style="color:red;font-weight:bold;">总结</span>    
在 app target 中 OC 和 Swift 的互相调用主要依赖两个文件       
<span style="color:red;font-weight:bold;">InvocationDemo-Bridging-Header.h</span>    
<span style="color:red;font-weight:bold;">InvocationDemo-Swift.h</span>    
<span style="color:red;font-weight:bold;">另外：OC和OC是头文件，Swift和Swift是swiftmodule</span>   
当我们创建一个Swift工程时，在工程内进行混编也是一样的道理。    


#### **二、在 library 内的互相调用**

library 内允许创建 OCLibrary-Bridging-Header.h 桥接头文件    

所以 library 内 OC 和 Swift 代码的调用同样依赖两个文件,跟在 App target 内并无区别         
Swift调用OC：<span style="color:red;font-weight:bold;">OCLibrary-Bridging-Header.h</span>          
OC调用Swift：<span style="color:red;font-weight:bold;">InvocationDemo-Swift.h</span>        
同样在编译产物里也能看到<span style="color:red;font-weight:bold;">OCLibrary.swiftmodule</span> 文件，用于Swift 和 Swift代码的调用      


#### **三、在 framework 内的互相调用**

不管是动态还是静态framework，我们在添加swift文件时不会在创建 Projectname-Bridging-Header.h文件       
在framework内，OC代码调用OC代码不会受影响        
OC代码通过Projectname-Swift.h文件可以调用到swift代码    
swift代码通过swiftmodule也可以调用到swift代码        
**那么我们Swift代码如何调用OC代码呢？**     

framework在构建时会生成modulemap文件，我们将OC的头文件放在modulemap里，就可以被swift引用到（lxy：modulemap跟swiftmodule应该有某种关联）          
我们查看产物里的modulemap发现SwiftFramework.h文件是modulemap文件的伞文件
```text
framework module SwiftFramework {
  umbrella header "SwiftFramework.h"
  export *

  module * { export * }
}

module SwiftFramework.Swift {
  header "SwiftFramework-Swift.h"
  requires objc
}
```

所以我们将oc的头文件放在伞文件下就可以了    
```text
#import <Foundation/Foundation.h>

//! Project version number for SwiftFramework.
FOUNDATION_EXPORT double SwiftFrameworkVersionNumber;

//! Project version string for SwiftFramework.
FOUNDATION_EXPORT const unsigned char SwiftFrameworkVersionString[];

// In this header, you should import all the public headers of your framework using statements like #import <SwiftFramework/PublicHeader.h>


// 需要用这种方式
#import <SwiftFramework/SwiftFrameOCPerson.h>

```


## <a id="content2">在不同的target内的互相调用</a>



**oc代码**    
1、使用oc代码（头文件、modulemap）

2、使用swift代码(-swift.h文件、modulemap可以也是因为子模块包含了-swift.h文件)    
-swift.h头文件没有被放到目录时，可以在下面存放中间产物的目录内找到
```text
/Users/YourUsername/Library/Developer/Xcode/DerivedData/YourProjectName-*/Build/Intermediates.noindex/YourLibraryName.build/Debug-iphoneos/YourLibraryName.build/Objects-normal/arm64/YourLibraryName-Swift.h
```


**swift代码**        
1、使用oc代码(需要把oc头文件放在swift代码所在 target 的 bridging-header.h文件内)       
2、使用oc代码(framework内不允许使用bridging-header.h,将oc头文件放在modulemap的伞文件内)              
3、使用swift代码(swiftmodule，不管是静态动态framework还是.a库只要包含swift代码都会有swiftmodule文件生成)    





----------
>  行者常至，为者常成！
