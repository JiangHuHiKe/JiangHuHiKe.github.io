---
layout: post
title: "flutter与原生应用"
date: 2022-03-01
tag: Flutter
---

## 目录
- [flutter页面的加载](#content1) 
- [channel的调用流程](#content2) 
- [Plugin介绍](#content3) 
- [鸿蒙与flutter的相互调用](#content4) 


## <a id="content1">flutter页面的加载</a>

以DF应用为例

```text
+ (instancetype)getFlutterViewControllerWithEntryPoint:(NSString *)entryPoint params:(NSDictionary *)params {
    // 初始化一个新的 FlutterEngine，并为其分配一个唯一的名称。
    // 通过这种方式，可以创建多个 Flutter 引擎实例，并在应用中根据需要进行区分。
    // 这个方法主要用于在 iOS 应用中，创建和管理多个 Flutter 引擎的场景。
    FlutterEngine *flutterEngine = [[FlutterEngine alloc] initWithName:entryPoint];
    
    // 启动 FlutterEngine 并设置引擎的入口点和初始路由的核心方法。通过这个方法，你可以灵活地控制 Flutter 引擎的启动行为，指定从哪个 Dart 函数开始执行以及一开始显示哪个页面。
    // entrypoint:指定 Flutter 引擎启动时需要调用的入口点函数名,默认为main。
    // initialRoute:指定 Flutter 引擎启动时的初始路由,默认使用 / 作为初始路由。
    [flutterEngine runWithEntrypoint:@"main" initialRoute:[NSString stringWithFormat:@"/%@",entryPoint]];
    
    // FlutterViewController视图控制器，负责在原生视图中呈现 Flutter 的 UI。它充当了 Flutter 与 iOS 原生界面之间的桥梁。
    //绑定engin是因为需要通过engin加载 Dart 代码、渲染Flutter 界面、处理Flutter与原生的消息通信
    FZFlutterViewController *viewController = [[FZFlutterViewController alloc] initWithEngine:flutterEngine entryPoint:entryPoint nibName:nil bundle:nil];
    
    // 注册插件,在 iOS 中，插件是用来扩展 Flutter 框架功能的一种方式。
    // 通过注册插件，你可以让你的应用能够使用各种原生平台的特性，比如访问设备硬件、调用系统服务等。
    // 插件是对channel的包装，后面会介绍      
    [GeneratedPluginRegistrant registerWithRegistry:viewController];
    
    return viewController;
}
```

## <a id="content2">channel的调用流程</a>

#### **一、Flutter调用原生**     

原生代码如下：    
```oc
// 初始化一个名为 syncData 的 channel，用于与 Flutter 进行通信。
FlutterMethodChannel *channel = [FlutterMethodChannel methodChannelWithName:@"syncData" binaryMessenger:self.engine.binaryMessenger];

// 向 Flutter 发送消息，请求执行 pop 方法并传递参数 param。
[channel invokeMethod:@"pop" arguments:@{@"param":@"123"} result:^(id  _Nullable result) {
    NSLog(@"result:%@", result);
}];
```
Flutter代码如下：    
```text
// channel 初始化
_channel = MethodChannel('syncData');
 
 // 向原生传递方法名pop和参数param
 // result为调用的返回值(注意：调用原生方法时返回值是异步返回的，后面会说明原因)        
 int result await _channel?.invokeMethod('pop', param)
 
 // 还可以用下面的这种书写方式
 _channel.invokeMethod('pop', param).then((result) {
     // 处理返回值
 });
```

OC代码如下：     
```oc

self.flutterInitChannel = [FlutterMethodChannel methodChannelWithName:@"syncData" binaryMessenger:self.engine.binaryMessenger];


// 调用后会来到原生注册的回调内
[self.flutterInitChannel setMethodCallHandler:^(FlutterMethodCall * _Nonnull call, FlutterResult  _Nonnull result) {
    if (call.method.equals("pop")) {
        // 获取参数
        id param = call.arguments; 
        
        // 处理具体逻辑
        ....
        
        // 返回结果
        int isSuccess = 1;
        result.success(isSuccess); 
    } else {
        result.notImplemented();
    }
}];

```
在DF内使用了一个单例对象来处理来自Flutter的调用     
```oc
[[FZFlutterChannelManager sharedInstance] dispatchChannel:call result:result context:strongSelf];


// flutterChannelDic存储的是FZFlutterChannel.plist文件内方法名与类的映射关系
// 通过 'pop' 找到 FZFlutterChannelPop 这个类，调用这个类的 【callWithChannel:result: context:]方法来处理这个调用   
- (void)dispatchChannel:(FlutterMethodCall *)call result:(FlutterResult)result context:(id)controller {
    NSString *className = [FZFlutterChannelManager sharedInstance].flutterChannelDic[call.method];
    if (className.length > 0) {
        Class class = NSClassFromString(className);
        if ([class conformsToProtocol:@protocol(FZFlutterChannelProtocol)]) {
            [class callWithChannel:call result:result context:controller];
        }
    } else {
        DDLogInfo(@"FlutterChannel 方法不存在");
    }
}
```


#### **二、原生调用Flutter**   
原生调用flutter与上边类似   

OC代码如下：    
```oc
// 创建 MethodChannel
FlutterMethodChannel *channel = [FlutterMethodChannel methodChannelWithName:@"com.example.flutter_channel"
                                                          binaryMessenger:self.flutterEngine.binaryMessenger];

// 调用 Flutter 端的方法
[channel invokeMethod:@"getGreeting" arguments:param result:^(id  _Nullable result) {
    // result是返回值
    if ([result isKindOfClass:[NSString class]]) {
        NSLog(@"Received greeting from Flutter: %@", result);
    } else {
        NSLog(@"Failed to get greeting from Flutter");
    }
}];
```

Flutter代码如下：    
```text
// 创建 MethodChannel
const MethodChannel channel = MethodChannel('com.example.flutter_channel');

// 注册 Flutter 端方法
channel.setMethodCallHandler((MethodCall call) async {
  if (call.method == 'getGreeting') {
    // 返回给原生端的响应
    return 'Hello from Flutter!';
  }
  return null;
});
```


## <a id="content3">Plugin介绍</a>




## <a id="content4">鸿蒙与flutter的相互调用</a>

#### **一、Harmony 中 flutter 通过channel 调用原生**

```text
// 注意继承关系
export default class SyncDataChannel extends MethodChannel implements MethodCallHandler {

    // flutter调用后会来到原生的这个方法
    onMethodCall(call: MethodCall, result: MethodResult): void {
        let method: string = call.method;
        switch (method) {
            case "pop":
                // 处理具体逻辑
                DfRouter.pop()
                break;
        }
    }
}
```

**iOS和Harmony处理的本质是一样的，都是判断方法名 "pop"后，处理具体业务逻辑，iOS只是包装了一个类来处理**   

----------
>  行者常至，为者常成！


