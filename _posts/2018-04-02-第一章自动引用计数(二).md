---
layout: post
title: "第一章 自动引用计数（二）"
date: 2018-04-02
description: "自动引用计数"
tag: Objective-C高级编程：iOS与OS X多线程和内存管理
---


<h6>
  <img src="https://robotkang-1257995526.cos.ap-chengdu.myqcloud.com/icon/copyright.png" alt="copyright" style="display:inline;margin-bottom: -5px;" width="20" height="20"> 版权声明：本文为博主原创文章，未经博主允许不得转载。

  <a target="_blank" href="https://jianghuhike.github.io/1842.html">
  原文地址：https://jianghuhike.github.io/1842.html 
  </a>
</h6>



 



## 目录


* [ARC规则](#content0)
* [ARC的实现](#content1)



<!-- ************************************************ -->
## <a id="content0"></a>ARC规则
### 一、概要

### 二、内存管理的思考方式
引用计数式内存管理的思考方式就是思考ARC所引起的变化。     
- 自己生成的对象，自己所持有
- 非自己生成的对象，自己也能持有
- 不再需要自己持有的对象时释放
- 无法释放非自己持有的对象

### 三、所有权修饰符
所谓对象类型就是指向NSObject这样的Objective-C类的指针，例如NSObject * ; id类型用于隐藏对象类型的类名部分，相当于C语言中常用的 void * ;    
ARC有效时，id类型和对象类型，必须附加所有权修饰符。     

- __strong修饰符

默认所有权修饰符    

```objc
//默认所有权修饰符为 __strong 相当于下面代码
id objc = [[NSObject alloc] init];

//__strong 修饰符
id __strong obj = [[NSObject alloc] init];
```

在特定作用域内的__strong

```objc
{
    //自己生成并持有对象
    //因为变量为强引用，所以自己持有对象
    id __strong obj = [[NSObject alloc] init];
}
//obj超出作用域，自动释放持有的对象
//对象的持有者不存在，因此废弃该对象
```


ARC无效时，该源代码可记述如下

```objc
{
    //创建并持有对象
    id obj = [[NSObject alloc] init];
    
    //在obj超出作用域被废弃之前释放掉持有对象
    [obj release];
}
```

赋值操作时的__strong
```objc
id __strong obj0 = [[NSObject alloc] init];//obj0持有对象A
id __strong obj1 = [[NSObject alloc] init];//obj1持有对象B

//obj0持有B对象
obj0 = obj1;

//此时obj0不再持有A对象，A对象释放
//B对象被obj0和obj1持有
```

类成员变量使用 __strong    
Test类的声明与实现
```objc
@interface Test:NSObject{
  id __strong obj_
}
@end

@implementation Test
-(id)init{
  self = [super init];
  return self;
}

-(void)setObject:(id __strong)obj{
  obj_ = obj;
}

@end

```

下面试着使用该类
```objc
{
  //test持有Test对象的强引用
  id __strong test = [[Test alloc] init];

  //Test对象的obj_成员持有NSObject对象的强引用
  [test setObject:[[NSObject alloc] init]];
}

//test变量超出其作用域，强引用失效，所以自动释放Test对象。Test对象的所有者不存在，因此废弃该对象。
//废弃Test对象的同时，Test对象的obj_成员也被废弃，NSObject对象的强引用失效，自动释放NSObject对象。NSObect对象的所有者不存在，因此废弃该对象。
```

**重要说明：**    
__strong __weak __ autoreleasing修饰符，可以保证将附有这些修饰符的自动变量初始化为nil;  
id __strong obj0;     
id __weak obj1;    
id __autoreleasing obj2;     

以下源代码与上相同     
id __strong obj0 = nil;       
id __weak obj1 = nil;      
id __autoreleasing obj2 = nil;    


***自己生成的对象，自己所持有 和 非自己生成的对象，自己也能持有***      
通过对带__strong修饰符的变量赋值便可达成。  
   
***不再需要自己持有的对象时释放***  
通过废弃带__strong修饰符的变量（变量作用域结束或是成员变量所属对象废弃）或者对变量赋值。

***无法释放非自己持有的对象***       
ARC下由于不必再次键入release，所以原本就不会执行。   







- __weak修饰符


- __unsafe_unretained修饰符




- __autoreleaseing修饰符



<!-- ************************************************ -->
## <a id="content0"></a>ARC的实现










----------
>  行者常至，为者常成！


