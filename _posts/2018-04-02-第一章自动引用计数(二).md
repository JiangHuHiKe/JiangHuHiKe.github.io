---
layout: post
title: "第一章 自动引用计数（二）"
date: 2018-04-02
description: "自动引用计数"
tag: Objective-C高级编程：iOS与OS X多线程和内存管理
---


<h6>
  <img src="https://robotkang-1257995526.cos.ap-chengdu.myqcloud.com/icon/copyright.png" alt="copyright" style="display:inline;margin-bottom: -5px;" width="20" height="20"> 版权声明：本文为博主原创文章，未经博主允许不得转载。

  <a target="_blank" href="https://jianghuhike.github.io/1842.html">
  原文地址：https://jianghuhike.github.io/1842.html 
  </a>
</h6>



 



## 目录


* [ARC规则](#content0)
* [ARC的实现](#content1)



<!-- ************************************************ -->
## <a id="content0"></a>ARC规则
### 一、概要

### 二、内存管理的思考方式
引用计数式内存管理的思考方式就是思考ARC所引起的变化。     
- 自己生成的对象，自己所持有
- 非自己生成的对象，自己也能持有
- 不再需要自己持有的对象时释放
- 无法释放非自己持有的对象

### 三、所有权修饰符
所谓对象类型就是指向NSObject这样的Objective-C类的指针，例如NSObject * ; id类型用于隐藏对象类型的类名部分，相当于C语言中常用的 void * ;    
ARC有效时，id类型和对象类型，必须附加所有权修饰符。     

- __strong修饰符

默认所有权修饰符    

```objc
//默认所有权修饰符为 __strong 相当于下面代码
id objc = [[NSObject alloc] init];

//__strong 修饰符
id __strong obj = [[NSObject alloc] init];
```

在特定作用域内的__strong

```objc
{
    //自己生成并持有对象
    //因为变量为强引用，所以自己持有对象
    id __strong obj = [[NSObject alloc] init];
}
//obj超出作用域，自动释放持有的对象
//对象的持有者不存在，因此废弃该对象
```


ARC无效时，该源代码可记述如下

```objc
{
    //创建并持有对象
    id obj = [[NSObject alloc] init];
    
    //在obj超出作用域被废弃之前释放掉持有对象
    [obj release];
}
```

赋值操作时的__strong
```objc
id __strong obj0 = [[NSObject alloc] init];//obj0持有对象A
id __strong obj1 = [[NSObject alloc] init];//obj1持有对象B

//obj0持有B对象
obj0 = obj1;

//此时obj0不再持有A对象，A对象释放
//B对象被obj0和obj1持有
```

类成员变量使用 __strong    
Test类的声明与实现
```objc
@interface Test:NSObject{
  id __strong obj_
}
@end

@implementation Test
-(id)init{
  self = [super init];
  return self;
}

-(void)setObject:(id __strong)obj{
  obj_ = obj;
}

@end

```

下面试着使用该类
```objc
{
  //test持有Test对象的强引用
  id __strong test = [[Test alloc] init];

  //Test对象的obj_成员持有NSObject对象的强引用
  [test setObject:[[NSObject alloc] init]];
}

//test变量超出其作用域，强引用失效，所以自动释放Test对象。Test对象的所有者不存在，因此废弃该对象。
//废弃Test对象的同时，Test对象的obj_成员也被废弃，NSObject对象的强引用失效，自动释放NSObject对象。NSObect对象的所有者不存在，因此废弃该对象。
```

**重要说明：**    
__strong __weak __ autoreleasing修饰符，可以保证将附有这些修饰符的自动变量初始化为nil;  
id __strong obj0;     
id __weak obj1;    
id __autoreleasing obj2;     

以下源代码与上相同     
id __strong obj0 = nil;       
id __weak obj1 = nil;      
id __autoreleasing obj2 = nil;    


***自己生成的对象，自己所持有 和 非自己生成的对象，自己也能持有***      
通过对带__strong修饰符的变量赋值便可达成。  
   
***不再需要自己持有的对象时释放***  
通过废弃带__strong修饰符的变量（变量作用域结束或是成员变量所属对象废弃）或者对变量赋值。

***无法释放非自己持有的对象***       
ARC下由于不必再次键入release，所以原本就不会执行。   



- __weak修饰符

只有__strong会出现循环引用问题

<img src="/images/memory/arc12.png" alt="img">


场景一：循环引用
```objc
{
  id test0 = [[Test alloc] init];//对象A
  id test1 = [[Test alloc] init];//对象B


  //持有对象B的有：test1,A对象->obj_; B的引用计数为2
  [test0 setObject:test1];

  //持有对象A的有：test0，B对象->obj_; A的引用计数为2
  [test1 setObject:test0];
}

//超出test0、test1的作用域范围，test0、test1废弃，分别放弃其持有的对象A、B；
//A与B的引用计数都变为1。对象A没有销毁，B也没有销毁。
```

<img src="/images/memory/arc13.png" alt="img">

场景二：对自身的强引用
```objc
{
  id test = [[Test alloc] init];//对象A 引用计数为1；

  [test setObject:test];//对象A->obj_ 赋值，对象A的引用计数为2；
}

//离开作用域，变量test被废弃，
//对象A的引用计数变为1，
//对象A，无法释放
```
<img src="/images/memory/arc14.png" alt="img">


场景三：__weak 修饰变量
```objc
{
  //obj0变量为强引用，所以自己持有对象
  id __strong obj0 = [[NSObject alloc] init];//生成对象A,引用计数为1

  //obj1变量持有生成对象的弱引用，不会导致引用计数改变
  id __weak obj1 = obj0;//对象A引用计数为1
}


//obj0超出作用域，强引用失效，自动释放自己持有的对象 对象A引用计数为0
//因为对象的所有者不存在，所以废弃该对象。
```

避免循环引用
```objc
@interface Test:NSObject{
  id __weak obj_;
}
-(void)setObject:(id __strong)obj;
@end;
```
<img src="/images/memory/arc15.png" alt="img">

自动失效且自动赋值nil;
```objc
//__weak修饰的变量，在持有对象被废弃，则此弱引用自动失效，且处于nil被赋值的状态。
id __weak obj1 = nil;

{
    id __strong obj0 = [[NSObject alloc] init];//obj0持有对象A
    
    obj1 = obj0;
    
    NSLog(@"obj1=%@",obj1);//obj1=<NSObject: 0x1c0011560>
}

NSLog(@"obj1=%@",obj1);// obj1=(null)
```
像这样，使用__weak修饰符可避免循环引用。通过检查附有__weak修饰符的变量是否为nil，可以判断被赋值的对象是否已废弃。




- __unsafe_unretained修饰符




- __autoreleaseing修饰符



<!-- ************************************************ -->
## <a id="content0"></a>ARC的实现










----------
>  行者常至，为者常成！


