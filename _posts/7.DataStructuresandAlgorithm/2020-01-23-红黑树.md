---
layout: post
title: "12、红黑树"
date: 2020-01-23
description: ""
tag: 数据结构与算法
---






## 目录

* [红黑树介绍](#content1)
* [添加](#content2)
* [删除](#content3)



<!-- ************************************************ -->
## <a id="content1"></a>红黑树介绍

**一、红黑树的性质**

红黑树也是一种自平衡的二叉搜索树    
以前也叫做平衡二叉B树（Symmetric Binary B-tree） 

<img src="/images/DataStructurs/rb1.png" alt="img">

红黑树必须满足以下 5 条性质
1. 节点是 RED 或者 BLACK   
2. 根节点是 BLACK   
3. 叶子节点（外部节点，空节点）都是 BLACK    
4. RED 节点的子节点都是 BLACK    
✓ RED 节点的 parent 都是 BLACK    
✓ 从根节点到叶子节点的所有路径上不能有 2 个连续的 RED 节点   
5. 从任一节点到叶子节点的所有路径都包含相同数目的 BLACK 节点     

<strong style="color:red">只要满足这些规则就能保证树的平衡。</strong>

为何这些规则下，就能保证平衡？

**请问下面这棵树是红黑树吗？**

<img src="/images/DataStructurs/rb2.png" alt="img">

不是，不满足性质5。不要忘记空节点的存在。55 -> 38 -> null 这也是一条路径。


**二、红黑树的等价变化**

<img src="/images/DataStructurs/rb3.png" alt="img">

◼ 红黑树 和 4阶B树（2-3-4树）具有等价性    
◼ BLACK 节点与它的 RED 子节点融合在一起，形成1个B树节点    
◼ 红黑树的 BLACK 节点个数 与 4阶B树的节点总个数 相等    
◼ 网上有些教程：用 2-3树 与 红黑树 进行类比，这是极其不严谨的，2-3树 并不能完美匹配 红黑树 的所有情况    
 
总结：    
1、二叉搜素树节点添加或删除完成后，需要变化为红黑树（保持平衡）。    
2、节点移动变化规则是参照B树的添加与删除规则进行变化的。    
3、颜色变化规则是依据：B树的节点是红黑树的黑节点。     

**红黑树 VS 2-3-4树**

<img src="/images/DataStructurs/rb4.png" alt="img">

◼ 思考：如果上图最底层的 BLACK 节点是不存在的，在B树中是什么样的情形？     
 整棵B树只有1个节点，而且是超级节点    


<!-- ************************************************ -->
## <a id="content2"></a>添加

◼ 已知   
 <strong style="color:red">B树中，新元素必定是添加到叶子节点中 </strong>         
 4阶B树所有节点的元素个数 x 都符合 1 ≤ x ≤ 3   

◼ 建议新添加的节点默认为 RED，这样能够让红黑树的性质尽快满足（性质 1、2、3、5 都满足，性质 4 不一定）   

叶子节点的所有情况如下图：

<img src="/images/DataStructurs/rb5.png" alt="img">



**情形一**

如果添加的是根节点，染成 BLACK 即可

**情形二**

◼ 有 4 种情况满足红黑树的性质 4 ：parent 为 BLACK    
同样也满足 4阶B树 的性质    
因此不用做任何额外处理    

<img src="/images/DataStructurs/rb6.png" alt="img">


**情形三**

◼ 有 8 种情况不满足红黑树的性质 4 ：parent 为 RED（ Double Red ）    
其中后 4 种属于B树节点只做旋转情况    
其中前 4 种属于B树节点上溢的情况    



<img src="/images/DataStructurs/rb7.png" alt="img">

**情形三：只做旋转情况**

◼ LL\RR 旋转：判定条件：uncle 不是 RED    
（1.） parent 染成 BLACK，grand 染成 RED    
（2.） grand 进行单旋操作    
LL：右旋转    
RR：左旋转    

<img src="/images/DataStructurs/rb8.png" alt="img">

◼ LR\RL 旋转：判定条件：uncle 不是 RED   
（1.） 自己染成 BLACK，grand 染成 RED    
（2.） 进行双旋操作     
LR：parent 左旋转， grand 右旋转    
RL：parent 右旋转， grand 左旋转     

<img src="/images/DataStructurs/rb9.png" alt="img">


**情形三：上溢情况**

◼ 上溢LL：判定条件 uncle 是 RED   
（1.） parent、uncle 染成 BLACK   
（2.） grand 向上合并    
染成 RED，当做是新添加的节点进行处理    

◼ grand 向上合并时，可能继续发生上溢    
◼ 若上溢持续到根节点，只需将根节点染成 BLACK    


<img src="/images/DataStructurs/rb11.png" alt="img">


◼ 上溢RR：判定条件：uncle 是 RED      
（1.） parent、uncle 染成 BLACK      
（2.） grand 向上合并      
染成 RED，当做是新添加的节点进行处理      

<img src="/images/DataStructurs/rb10.png" alt="img">


◼ 上溢LR：判定条件 uncle 是 RED      
（1.） parent、uncle 染成 BLACK     
（2.） grand 向上合并     
染成 RED，当做是新添加的节点进行处理     

<img src="/images/DataStructurs/rb12.png" alt="img">

◼ 上溢RL：判定条件 uncle 是 RED   
（1.） parent、uncle 染成 BLACK   
（2.） grand 向上合并    
染成 RED，当做是新添加的节点进行处理    

<img src="/images/DataStructurs/rb13.png" alt="img">



<!-- ************************************************ -->
## <a id="content3"></a>删除

<strong style="color:red">B树中，最后真正被删除的元素都在叶子节点中</strong>

<img src="/images/DataStructurs/rb14.png" alt="img">


**一、删除RED节点**

直接删除，不用作任何调整

<img src="/images/DataStructurs/rb15.png" alt="img">


**二、删除BLACK节点**

<img src="/images/DataStructurs/rb16.png" alt="img">

拥有 2 个 RED 子节点的 BLACK 节点    
✓ 不可能被直接删除，因为会找它的子节点替代删除(前序或后继节点)   
✓ 因此不用考虑这种情况   

拥有 1 个 RED 子节点的 BLACK 节点  

BLACK 叶子节点

**情形一：删除 – 拥有1个RED子节点的BLACK节点**

◼ 判定条件：用以替代的子节点是 RED    
◼ 将替代的子节点染成 BLACK 即可保持红黑树性质    

<img src="/images/DataStructurs/rb17.png" alt="img">


**情形二：删除 – BLACK叶子节点 – sibling为BLACK**

◼BLACK 叶子节点被删除后，会导致B树节点下溢（比如删除88） ◼ 如果 sibling 至少有 1 个 RED 子节点    
进行旋转操作    
旋转之后的中心节点继承 parent 的颜色    
旋转之后的左右节点染为 BLACK   
  

----------
>  行者常至，为者常成！


