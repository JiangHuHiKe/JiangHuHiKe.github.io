---
layout: post
title: "14、哈希表"
date: 2020-01-27
description: ""
tag: 数据结构与算法
---






## 目录

* [TreeMap分析](#content1)
* [哈希表](#content2)
* [哈希函数](#content3)
* [哈希值](#content4)







<!-- ************************************************ -->
## <a id="content1"></a>TreeMap分析

◼ 时间复杂度（平均）   
添加、删除、搜索：O(logn)

◼ 特点   
Key 必须具备可比较性   
元素的分布是有顺序的    

◼ 在实际应用中，很多时候的需求    
Map 中存储的元素不需要讲究顺序    
Map 中的 Key 不需要具备可比较性    

◼ 不考虑顺序、不考虑 Key 的可比较性，Map 有更好的实现方案，平均时间复杂度可以达到 O(1)    
那就是采取哈希表来实现 Map    

<!-- ************************************************ -->
## <a id="content2"></a>哈希表

**一、设计一个需求**

设计一个写字楼通讯录，存放所有公司的通讯信息      
座机号码作为 key（假设座机号码最长是 8 位），公司详情（名称、地址等）作为 value    
添加、删除、搜索的时间复杂度要求是 O(1)  

|索引| 数据|
|01||
|...||
|40089008| 百度|
|...||
|68485438| 阿里|
|...||
|99999999||


存在什么问题？    
空间复杂度非常大     
空间使用率极其低，非常浪费内存空间     
其实数组 companies 就是一个哈希表，典型的【空间换时间】    

**二、哈希表 Hash Table**

◼ 哈希表也叫做散列表（ hash 有“剁碎”的意思）         
◼ 它是如何实现高效处理数据的？         
put("Jack", 666);   
put("Rose", 777);    
put("Kate", 888);    

<img src="/images/DataStructurs/hash1.png" alt="img">

◼ 添加、搜索、删除的流程都是类似的    
1. 利用哈希函数生成 key 对应的 index【O(1)】   
2. 根据 index 操作定位数组元素【O(1)】    
◼ 哈希表是【空间换时间】的典型应用      
◼ 哈希函数，也叫做散列函数      
◼ 哈希表内部的数组元素，很多地方也叫 Bucket（桶），整个数组叫 Buckets 或者 Bucket Array       


**三、哈希冲突**

◼ 哈希冲突也叫做哈希碰撞     
2 个不同的 key，经过哈希函数计算出相同的结果    
key1 ≠ key2 ，hash(key1) = hash(key2)   

<img src="/images/DataStructurs/hash2.png" alt="img">

◼ 解决哈希冲突的常见方法    
1. 开放定址法（Open Addressing）     
✓ 按照一定规则向其他地址探测，直到遇到空桶    
2. 再哈希法（Re-Hashing）     
✓ 设计多个哈希函数    
3. 链地址法（Separate Chaining）    
✓ 比如通过链表将同一index的元素串起来    


**四、解决哈希冲突的方案**


◼ 默认使用单向链表将元素串起来    
◼ 在添加元素时，可能会由单向链表转为红黑树来存储元素    
比如当哈希表容量 ≥ 64 且 单向链表的节点数量大于 8 时  

◼ 当红黑树节点数量少到一定程度时，又会转为单向链表    
◼ JDK1.8中的哈希表是使用链表+红黑树解决哈希冲突    


<img src="/images/DataStructurs/hash3.png" alt="img">


◼ 思考：这里为什么使用单链表？    
每次都是从头节点开始遍历   
单向链表比双向链表少一个指针，可以节省内存空间     
 


<!-- ************************************************ -->
## <a id="content3"></a>哈希函数


◼ 哈希表中哈希函数的实现步骤大概如下    
1. 先生成 key 的哈希值（必须是整数）    
2. 再让 key 的哈希值跟数组的大小进行相关运算，生成一个索引值    

<img src="/images/DataStructurs/hash4.png" alt="img">


◼ 为了提高效率，可以使用 & 位运算取代 % 运算【前提：将数组的长度设计为 2 的幂（2^n）】

<img src="/images/DataStructurs/hash5.png" alt="img">

◼ 良好的哈希函数     
让哈希值更加均匀分布 → 减少哈希冲突次数 → 提升哈希表的性能     


<!-- ************************************************ -->
## <a id="content4"></a>哈希值


◼ key 的常见种类可能有    
整数、浮点数、字符串、自定义对象    
不同种类的 key，哈希值的生成方式不一样，但目标是一致的    
✓ 尽量让每个 key 的哈希值是唯一的     
✓ 尽量让 key 的所有信息参与运算     
◼ 在Java中，HashMap 的 key 必须实现 hashCode、equals 方法，也允许 key 为 null


**一、整数的哈希值**

整数值当做哈希值   
比如 10 的哈希值就是 10    

<img src="/images/DataStructurs/hash6.png" alt="img">


**二、浮点数的哈希值** 

将存储的二进制格式转为整数值        

<img src="/images/DataStructurs/hash7.png" alt="img">


**三、Long和Double的哈希值**

<img src="/images/DataStructurs/hash8.png" alt="img">

◼ > > > 和 ^ 的作用是？     
高32bit 和 低32bit 混合计算出 32bit 的哈希值     
充分利用所有信息计算出哈希值       

<img src="/images/DataStructurs/hash9.png" alt="img">


**四、字符串的哈希值**

◼ 整数 5489 是如何计算出来的？    
5 ∗ 10^3 + 4 ∗ 10^2 + 8 ∗ 10^1 + 9 ∗ 10^0     

◼ 字符串是由若干个字符组成的       
比如字符串 jack，由 j、a、c、k 四个字符组成（字符的本质就是一个整数）         
因此，jack 的哈希值可以表示为 j ∗ n^3 + a ∗ n^2 + c ∗ n^1 + k ∗ n^0，等价于 [ ( j ∗ n + a ) ∗ n + c ] ∗ n + k     

在JDK中，乘数 n 为 31，为什么使用 31？     
✓ 31 是一个奇素数，JVM会将 31 * i 优化成 (i << 5) – i    

<img src="/images/DataStructurs/hash10.png" alt="img">


关于31的探讨    
◼ 31 * i = (2^5 – 1) * i = i * 2^5 – i = (i << 5) – i     
◼ 31不仅仅是符合2^n – 1，它是个奇素数（既是奇数，又是素数，也就是质数）    
素数和其他数相乘的结果比其他方式更容易产成唯一性，减少哈希冲突     
最终选择31是经过观测分布结果后的选择     

**五、自定义对象的哈希值**

<img src="/images/DataStructurs/hash11.png" alt="img">


**自定义对象作为key**

◼ 自定义对象作为 key，最好同时重写 hashCode 、equals 方法    

equals ：用以判断 2 个 key 是否为同一个 key
✓ 自反性：对于任何非 null 的 x，x.equals(x)必须返回true 

✓ 对称性：对于任何非 null 的 x、y，如果 y.equals(x) 返回 true，x.equals(y) 必须返回 true     

✓ 传递性：对于任何非 null 的 x、y、z，如果 x.equals(y)、y.equals(z) 返回 true，那么x.equals(z) 必须返回 true          

✓ 一致性：对于任何非 null 的 x、y，只要 equals 的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y) 就会一致地返回 true，或者一致地返回 false

✓ 对于任何非 null 的 x，x.equals(null) 必须返回 false

<span style="color:red">hashCode ：必须保证 equals 为 true 的 2 个 key 的哈希值一样</span>

<span style="color:red">反过来 hashCode 相等的 key，不一定 equals 为 true</span>

◼ 不重写 hashCode 方法只重写 equals 会有什么后果？

✓ 可能会导致 2 个 equals 为 true 的 key 同时存在哈希表中


**六、哈希值的进一步处理：扰动计算**

<img src="/images/DataStructurs/hash12.png" alt="img">

为什么要进行扰动计算，避免导致哈希碰撞的概率较大。

比如 table.length - 1 是 16 位的二进制数。那么 & 的结果必然是只取哈希值的前16位进行计算。
比如哈希值为：
0100 0000 0000 0000 1010 1010 1010 1010      
0110 0000 0000 0000 1010 1010 1010 1010

如果没有扰动计算 这两个哈希值计算的索引相同，导致哈希碰撞    
如果有扰动计算 这两个哈希值计算的索引不同，避免了哈希碰撞    





----------
>  行者常至，为者常成！


