---
layout: post
title: "5、字符串"
date: 2020-05-09
description: ""
tag: 数据结构与算法（三）
---






## 目录

* [01.09. 字符串轮转](#content1)
* [242. 有效的字母异位词](#content2)
* [572. 另一个树的子树](#content3)









<!-- ************************************************ -->
## <a id="content1"></a>01.09. 字符串轮转

**题目描述**
```
 01.09. 字符串轮转
 字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（
 比如，waterbottle是erbottlewat旋转后的字符串）。

 示例1:
  输入：s1 = "waterbottle", s2 = "erbottlewat"
  输出：True
 
 示例2:
  输入：s1 = "aa", s2 = "aba"
  输出：False
 
 提示：
 字符串长度在[0, 100000]范围内。
 
 说明:
 你能只调用一次检查子串的方法吗？

 来源：力扣（LeetCode）
 链接：https://leetcode-cn.com/problems/string-rotation-lcci
 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 ```

**题目实现**

```
class Solution {
public:
    bool isFlipedString(string s1, string s2) {
        if(s1.compare(s2) == 0) return true;
        if (s1 == "" || s2 == "") return false;
        if (s2.length() > s1.length()) return false;
        s1.append(s1);
        return s1.find(s2) != -1;
    }
};
```


<!-- ************************************************ -->
## <a id="content2"></a>242. 有效的字母异位词


**题目描述**

```
242. 有效的字母异位词
 
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1:
输入: s = "anagram", t = "nagaram"
输出: true

示例 2:
输入: s = "rat", t = "car"
输出: false

说明:
你可以假设字符串只包含小写字母。

进阶:
如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/valid-anagram
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```


**题目实现**

```
class Solution {
public:
    bool isAnagram(string s, string t) {

        if (s.length() != t.length()) return false;
       
        vector<int> results(26);
       
        int length = (int)s.length();
        for (int i = 0; i<length; i++) {
            ++results[s[i]-'a'];
        }
        
        for (int i = 0; i<length; i++) {
            int val = --results[t[i]-'a'];
            if (val<0) return false;
        }

        return true;
    }
};
```

 <!-- ************************************************ -->
## <a id="content3"></a>572. 另一个树的子树


**题目描述**

```
572. 另一个树的子树
 
 给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。

 示例 1:
 给定的树 s:

      3
     / \
    4   5
   / \
  1   2
 给定的树 t：

    4
   / \
  1   2
 返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。

 示例 2:
 给定的树 s：

      3
     / \
    4   5
   / \
  1   2
     /
    0
 给定的树 t：

    4
   / \
  1   2
 返回 false。

 来源：力扣（LeetCode）
 链接：https://leetcode-cn.com/problems/subtree-of-another-tree
 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 ```


**题目实现**

```
class Solution {
public:
    bool isSubtree(TreeNode* s, TreeNode* t) {
        if (s == nullptr || t == nullptr) return false;
        
        string * s1 = new string();
        postorder(s1, s);
        
        string * s2 = new string();
        postorder(s2, t);

        return (int)s1->find(*s2) != -1;
    }
    
    void postorder(string* result, TreeNode* node){
        if (node == nullptr){
            result->append("#!");
            return;
        }
        postorder(result,node->left);
        postorder(result,node->right);
        //打印节点
        
        result->append(to_string(node->val));
        result->append("!");
    }
};
```



----------
>  行者常至，为者常成！


