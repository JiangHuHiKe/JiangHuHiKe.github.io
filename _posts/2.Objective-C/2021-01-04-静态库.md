---
layout: post
title: "静态库"
date: 2021-01-04
tag: Objective-C
---


## 目录
- [待整理](#content1)   


 
<!-- ************************************************ -->
## <a id="content1">待整理</a>

```
0301 man nm 与 common符号

一. 查看一个命令是做什么的

1. 使用man命令
man nm
man objdump
man git

2. 使用--help
nm --help
objdump --help
git --help
```


```
0302 链接AFN生成目标文件

一.
command + k 清除终端屏幕

二.
.a  静态库
.dylib 动态库
.framework 动静结合
.xcframework 不同的架构连接所需的framework


三.命令
//查看文件类型
file libAFNetworking.a

//验证libAFNetworking.a是.o文件的合集
ar -t libAFNetworking.a

//如果只有一个xxx.m文件
我们将xxx.m文件编译为xxx.o文件
将xxx.o文件直接修改文件名为libxxx.a,它就可以作为一个静态库使用
从另外一个角度证明,静态库就是.o文件的合集.



四. 生成目标文件
man clang 查看clang命令
目标文件.o内有,重定位符号表,表内只需要标记哪些符号需要重定位所以
对libAFNetworking.a而言,生成目标文件的过程只需要头文件即可.



五.快捷键
control + E  定位到尾部
control + W  向前清除一个单词
```


```
0303 链接静态库生成可执行文件

一.符号表
.o文件的重定位符号表
.o文件的重定位符号表

链接后,所有的重定位符号表都会被放入一个统一的符号表中


二. 链接库的三要素
头文件路径               header search path
library 路径            libaray search path
library 名称            other link flag -lAFNetworking


三.证明静态库文件就是.o文件合集
将test.m文件编译为test.o文件
将test.o文件改为libTest.dylib文件,然后将后缀dylib去掉
```

```
0304 framework初探

一.静态库合并
就是将A静态库的.o文件和B静态库的.o文件放在一块,就是静态库合并.

libtool - create libraries
ranlib - add or update the table of contents of archive libraries


二.头文件 

mudule -> .h
.h -> 二进制,不用每次都编译


三. framework

静态库:头文件 + .a + 签名 + 资源文件
动态库:头文件 + dylib + 签名 + 资源文件
```

```
0305 framework

一. 自己创建一个framework

二. 链接一个framework

```

```
0306 shell

一.sh文件格式
build.sh 

二. 将指令放入build.sh文件

三. 获取权限:chmod +X ./build.sh 

四. shell的基本使用

echo "------"           #打印
pushd ./StaticLibrary   #进入一个目录
popd                    #回到上一级目录
CustomVar = xxxx        #变量
$CustomVar              #变量使用
${CustomVar}.mm         #变量使用
```


```
0307 dead strip

一. 查看代码段
objdump --macho -d test


二.dead code strip

1.
embed 会将静态库拷贝到bundle包内

2.
clang 默认是开启dead code strip ,没有使用的方法不会放到代码段
dead code strip 是在链接阶段起作用,在链接过程中将分类的代码脱掉了.

个人理解:
OC分类的方法是在运行时阶段添加,不是在链接阶段,比如我们有个分类里有一个test_category方法
那么在链接阶段在类的方法列表里找不到test_category方法,那么在链接阶段就会认为test_category是死代码,
dead code strip 就会将相应的代码脱掉.

3.
-all_load   Loads all members of static archive libraries.
-all_load 参数 告诉链接器不要脱掉任何代码,把所有的代码都加进去
这样我们就享受不到链接器对我们进行的优化,因为所有的代码都被加进去了.


4.
other link flag 是通过 clang 给我们的链接器传递参数的
-Xlinker 是告诉clang 我们是给ld传递参数的


5.-ObjC 只加载OC的
-ObjC       Loads all members of static archive libraries that implement an Objective-C class or category.


6. -force_load 指定加载哪些静态库
-force_load path_to_archive
Loads all members of the specified static archive library.  
Note: -all_load forces all members of all archives to be loaded.
This option allows you to target a specific archive.


7.xcode 的dead code strip 为什么没有脱掉没有使用的代码
.o -> .o  会先放入一个大的.o再链接成可执行文件,链接时dead code strip
.0 -> .a  .a放进来时执行dead code strip,然后执行真正的链接.
LTO

8. 说明
other link flag 的 -all_load ,  -ObjC , -force_load 是对链接阶段的链接配置
dead code strip 也是作用在链接阶段,但跟other link flag是两回事.
```

```
0308 下节课内容

动态库加载原理 -> dyld image not found 路径
实际开发.动态库与静态库的链接场景
    
```

```s
#build.sh 样例

LANGUAGE=objective-c
TAREGT=x86_64-apple-macos11.1
SYSROOT=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk

FILE_NAME=test
STATICLIBRARY=TestExample
HEAD_PATH=./StaticLibrary
LIBRARY_PATH=./StaticLibrary

echo "-------------编译test.m to test.o------------------"
clang -x $LANGUAGE  \
-target $TAREGT     \
-fobjc-arc          \
-isysroot $SYSROOT  \
-I${HEAD_PATH}   \
-c ${FILE_NAME}.m -o ${FILE_NAME}.o

echo "-------------进入到StaticLibrary目录------------------"
pushd ${HEAD_PATH}
echo "-------------编译TestExample.m to TestExample.o------------------"
clang -x $LANGUAGE  \
-target $TAREGT     \
-fobjc-arc          \
-isysroot $SYSROOT  \
-c ${STATICLIBRARY}.m -o ${STATICLIBRARY}.o
echo "-------------退出StaticLibrary目录------------------"

popd

echo "-------------test.o链接libTestExample.a to test EXEC------------------"
clang -target $TAREGT   \
-fobjc-arc              \
-isysroot $SYSROOT      \
-L${LIBRARY_PATH}       \
-l${STATICLIBRARY}           \
$FILE_NAME.o -o $FILE_NAME
```



----------
>  行者常至，为者常成！


