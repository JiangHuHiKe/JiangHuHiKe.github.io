---
layout: post
title: "符号表"
date: 2021-01-02
tag: Objective-C
---






## 目录
- [nm命令](#content1)   
- [在xcconfig文件内配置](#content2)   
- [符号的可见性](#content3)   




<!-- ************************************************ -->
## <a id="content1">nm命令</a>

**nm --help命令**

```
╰─○ nm --help
OVERVIEW: llvm symbol table dumper

USAGE: nm [options] <input files>

OPTIONS:

Generic Options:

  --help             - Display available options (--help-hidden for more)
  --help-list        - Display list of available options (--help-list-hidden for more)
  --version          - Display the version of this program

llvm-nm Options:

  -B                 - Alias for --format=bsd
  -P                 - Alias for --format=posix
  --add-dyldinfo     - Add symbols from the dyldinfo not already in the symbol table, Mach-O only

...

```

**nm --version**

```
╰─○ nm --version
Apple LLVM version 12.0.5 (clang-1205.0.22.11)
  Optimized build.
  Default target: x86_64-apple-darwin20.5.0
  Host CPU: broadwell
```


**nm -pa inputfiles**

```
// -p : 不排序
// -a : 显示所有符号,包括调试符号

╰─○ nm -pa machoinfo 
0000000100001020 t _read_magic
0000000100001080 t _is_magic_64
00000001000010b0 t _should_swap_bytes
0000000100001100 t _is_fat
0000000100001130 t _dump_fat_header
...

```


<!-- ************************************************ -->
## <a id="content2">在xcconfig文件内配置</a>

**.xcconfig文件**

```
// -p : 不排序
// -a : 显示所有符号,包括调试符号
MACHO_PATH=${BUILD_DIR}/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)/LCClientDemo.app/LCClientDemo
CMD = nm
CMD_FLAG = -pa ${MACHO_PATH}
TTY = /dev/ttys002

OTHER_LDFLAGS = $(inherited) -Xlinker -S
```

**Build Phases -> Run Script**

```
/bin/sh "$SRCROOT/LCClientDemo/Script/xcode_run_cmd.sh"
```

**xcode_run_cmd.sh**

```
#!/bin/sh


RunCommand() {
  #判断全局字符串VERBOSE_SCRIPT_LOGGING是否为空。-n string判断字符串是否非空
  #[[是 bash 程序语言的关键字。用于判断
  if [[ -n "$VERBOSE_SCRIPT_LOGGING" ]]; then
    #作为一个字符串输出所有参数。使用时加引号"$*" 会将所有的参数作为一个整体，以"$1 $2 … $n"的形式输出所有参数
      if [[ -n "$TTY" ]]; then
          echo "♦ $@" 1>$TTY
      else
          echo "♦ $*"
      fi
      echo "------------------------------------------------------------------------------" 1>$TTY
  fi
  #与$*相同。但是使用时加引号，并在引号中返回每个参数。"$@" 会将各个参数分开，以"$1" "$2" … "$n" 的形式输出所有参数
  if [[ -n "$TTY" ]]; then
      echo `$@ &>$TTY`
  else
      "$@"
  fi
  #显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。
  return $?
}

EchoError() {
    #在shell脚本中，默认情况下，总是有三个文件处于打开状态，标准输入(键盘输入)、标准输出（输出到屏幕）、标准错误（也是输出到屏幕），它们分别对应的文件描述符是0，1，2
    # >  默认为标准输出重定向，与 1> 相同
    # 2>&1  意思是把 标准错误输出 重定向到 标准输出.
    # &>file  意思是把标准输出 和 标准错误输出 都重定向到文件file中
    # 1>&2 将标准输出重定向到标准错误输出。实际上就是打印所有参数已标准错误格式
    if [[ -n "$TTY" ]]; then
        echo "$@" 1>&2>$TTY
    else
        echo "$@" 1>&2
    fi
    
}

RunCMDToTTY() {
    if [[ ! -e "$TTY" ]]; then
        EchoError "=========================================="
        EchoError "ERROR: Not Config tty to output."
        exit -1
    fi
    
    if [[ -n "$CMD" ]]; then
        RunCommand "$CMD" ${CMD_FLAG}
    else
        EchoError "=========================================="
        EchoError "ERROR:Failed to run CMD. THE CMD must not null"
    fi
}


RunCMDToTTY

```


<!-- ************************************************ -->
## <a id="content3">符号的可见性</a>


**符号可见性**

-O1 -Oz 生成目标文件时 在编译阶段的处理

dead code strip 死代码剥离 在链接阶段处理

strip 剥离符号 mach-O修改 (deployment postprocessing 设置为yes)


**xcode设置strip**

1  找到下面的设置组   

Build Settings -> Deployment 


2  找到下面的设置项,设置为YES    

Deployment PostProcessing 设置为 YES     


3  找到下面的设置项进行配置

Strip style 的类型选择

All Symbols      
Non-Global Symbols     
Debugging Symbols     


 

















----------
>  行者常至，为者常成！


