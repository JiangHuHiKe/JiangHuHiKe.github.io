---
layout: post
title: "暂存1"
date: 2017-01-07
tag: Objective-C
---


[参考:iOS基础进阶班合辑-大神推荐](https://ke.qq.com/course/package/15652)      
<span style="font-weight:bold;color:red;">本文是上面课程的摘要,只用于自己快速浏览.</span>


## 目录
* [1 Interview For OC ](#content1)
* [2 Interview For Runtime](#content2)
* [3 Interview For Runloop](#content3)
* [4 Interview For Thread](#content4)
* [5 Interview For Memory](#content5)
* [6 内存优化](#content6)
* [7 设计模式与架构](#content7)




<!-- ************************************************ -->
## <a id="content1">1 Interview For OC </a>

```
1、一个NSObject对象占用多少内存？

	系统分配了16个字节给NSObject对象（通过malloc_size函数获得）
	但NSObject对象内部只使用了8个字节的空间（64bit环境下，可以通过class_getInstanceSize函数获得）


2、对象的isa指针指向哪里？
	instance对象的isa指向class对象
	class对象的isa指向meta-class对象
	meta-class对象的isa指向基类的meta-class对象


3、OC的类信息存放在哪里？
	成员变量的具体值，存放在instance对象
	对象方法、属性、成员变量、协议信息，存放在class对象中
	类方法，存放在meta-class对象中


4、iOS用什么方式实现对一个对象的KVO？(KVO的本质是什么？)
	利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类
	当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAndNotify函数
		willChangeValueForKey:
		父类原来的setter
		didChangeValueForKey:
			内部会触发监听器（Oberser）的监听方法( observeValueForKeyPath:ofObject:change:context:）


5、如何手动触发KVO？
	手动调用willChangeValueForKey:和didChangeValueForKey:


6、直接修改成员变量会触发KVO么？
	不会触发KVO
	调用对象的set方法才会触发kvo


7、通过KVC修改属性会触发KVO么？
	会触发KVO



8、KVC的赋值和取值过程是怎样的？原理是什么？

	赋值
		会先去找setKey _setKey方法
		如果找不到方法就会调用是否允许直接访问成员变量的方法
		找成员变量 _key _isKey key isKey
		setValue:forUndefinedKey:方法

	取值与赋值类似
		先找成员方法：getKey key _key isKey
		调用是否允许直接访问成员变量
		找成员变量：_key isKey key isKey
		valueForUndefinedKey:
	
	原理是什么
		先找方法，再找成员变量
		都找不到就抛错



9、Category的使用场合是什么？
	为类动态添加对象方法、类方法、属性、协议
	可以为系统类、三方库添加


10、Category的实现原理
	Category编译之后的底层结构是struct category_t，里面存储着分类的对象方法、类方法、属性、协议信息
	在程序运行的时候，runtime会将Category的数据，合并到类信息中（类对象、元类对象中）


11、Category和Class Extension的区别是什么？
	Class Extension在编译的时候，它的数据就已经包含在类信息中
	Category是在运行时，才会将数据合并到类信息中



12、Category中有load方法吗？load方法是什么时候调用的？load 方法能继承吗？
	有load方法
	load方法在runtime加载类、分类的时候调用
	load方法可以继承，但是一般情况下不会主动去调用load方法，都是让系统自动调用


13、load、initialize方法的区别什么？它们在category中的调用的顺序？以及出现继承时他们之间的调用过程？
	load方法在runtime加载类、分类的时候调用，且只调用一次
	initialize方法在类对象第一次接收到消息时调用
	在分类的load的方法也只调用一次，分类的initialize方法会覆盖类的initialize方法，且后编译的分类覆盖先编译的分类的initialize方法
	继承时先load先调用父类再调用子类，然后在调用父类分类，最后调用子类分类。initialize先调用父类再调用子类


14、Category能否添加成员变量？如果可以，如何给Category添加成员变量？
	不能直接给Category添加成员变量，
	但是可以使用关联对象间接实现Category有成员变量的效果



15、block的原理是怎样的？本质是什么？
	block的本质是OC对象，有impl,des两个成员变量，impl下有个指向函数的指针。
	block的调用就是OC对象下impl下成员函数的调用
	所以block是封装了函数调用以及调用环境的OC对象



16、__block的作用是什么？有什么使用注意点？
	__block的作用是将修饰的变量包装成一个block_byref的对象，可以做到在block表达式内修改变量值的作用
	默认是强引用
	block_byref对象下有个forwarding指针，要注意它的指向


17、block的属性修饰词为什么是copy？使用block有哪些使用注意？
	block一旦没有进行copy操作，就不会在堆上
	使用注意：循环引用问题


18、block在修改NSMutableArray，需不需要添加__block？
	NSMutableArray * array =  [NSMutableArray array];
	array =  [NSMutableArray array];需要
	[array addObject:xxx];不需要

```


<!-- ************************************************ -->
## <a id="content2">2 Interview For Runtime</a>


```
1、讲一下 OC 的消息机制
	OC中的方法调用其实都是转成了objc_msgSend函数的调用，给receiver（方法调用者）发送了一条消息（selector方法名）
	objc_msgSend底层有3大阶段
		消息发送（当前类、父类中查找）
		动态方法解析
		消息转发



2、消息转发机制流程
	-(id)forwardingTargetForSelector:(SEL)aSelector
	- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
	- (void)forwardInvocation:(NSInvocation *)anInvocation



3、什么是Runtime？平时项目中有用过么？
	OC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行
	OC的动态性就是由Runtime来支撑和实现的，Runtime是一套C语言的API，封装了很多动态性相关的函数
	平时编写的OC代码，底层都是转换成了Runtime API进行调用
	具体应用
		利用关联对象（AssociatedObject）给分类添加属性
		遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）
		交换方法实现（交换系统的方法）
		利用消息转发机制解决方法找不到的异常问题
		字典转模型、自动编解码



4、打印结果分别是什么？
	NSLog(@"[person class]     = %@",[self class]);
    	NSLog(@"[self superclass]  = %@",[self superclass]);
    	NSLog(@"[super  class]     = %@",[super  class]);
    	NSLog(@"[super superclass] = %@",[super superclass]);



5、打印结果分别是什么？
	NSLog(@"%d",[NSObject isMemberOfClass:[NSObject class]]);//0
	NSLog(@"%d",[NSObject isKindOfClass:[NSObject class]]);//1
	NSLog(@"%d",[Person isMemberOfClass:[Person class]]);//0
	NSLog(@"%d",[Person isKindOfClass:[Person class]]);//0



6、以下代码能不能执行成功？如果可以，打印结果是什么？
	- (void)viewDidLoad {
    [super viewDidLoad];
    id cls = [Person class];
    void * obj = &cls;
    [(__bridge id)obj print];
	}

```



<!-- ************************************************ -->
## <a id="content3">3 Interview For Runtime</a>

```
1、讲讲 RunLoop，项目中有用到吗？
	运行循环，在线程中用于不停的调度工作和处理事件，让线程有工作的时候忙于工作，没工作的时候处于休眠，节省资源提高性能
	比如主线程的运行循环是主动开启的，可以保持线程持续运行，可以处理触摸事件，定时器事件。
	控制线程生命周期（线程保活）
	解决NSTimer在滑动时停止工作的问题
	自动释放池
	监控应用卡顿
	性能优化



2、runloop内部实现逻辑？
	runloop需要一个for或while循环来作为驱动
	runloop对象处理事件需要运行在特定的mode下，且一次只能运行在一种mode下，这样可以隔绝与该模式无关的输入源
	mode的数据结构包含了timer,source0,source1,observer.timer用于处理定时器事件，source0用于触摸事件，source1用于线程间通讯，oberserver用于监听runloop运行状态
	另外runloop还有一个事件队列，用于协调timer,source0,source1,observer的处理顺序


3、runloop和线程的关系？
	一个线程与一个runloop一一对应
	runloop保存在一个全局的dictionary里，线程做key，runloop做value
	只有主线程的runloop会默认开启，子线程刚创建时没有runloop，runloop在第一次获取它时创建



4、timer 与 runloop 的关系？
	timer是runloop输入源的一种，并且默认在NSDefaultRunLoopMode模式下工作
	当我们滑动tableview的时候，timer就会停止工作，这时需要将timer添加到UITrackingRunLoopMode



5、程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？
	timer工作在NSDefaultRunLoopMode，拖动tableview时runloop处在UITrackingRunLoopMode模式下
	解决这个问题只要把timer添加到UITrackingRunLoopMode模式下即可


6、runloop 是怎么响应用户操作的， 具体流程是什么样的？



7、说说runLoop的几种状态
	进入runloop
	处理timer
	处理sources
	进入睡眠状态
	将要被唤醒
	退出runloop


8、runloop的mode作用是什么？
	runloop对象处理事件需要运行在特定的mode下，且一次只能运行在一种mode下
	这样可以隔绝与该mode无关的事件
	比如定时器工作在defaultMode下，当tableView滑动时runloop工作在trackingMode下，这是定时器就会失效
```

<!-- ************************************************ -->
## <a id="content4">4 Interview For Runtime</a>

```

1、你理解的多线程？

	单个应用程序的多条代码路径
	可以提高应用程序的感知响应，比如主线程处理UI，子线程处理耗时操作
	可以提高应用程序在多核系统上的性能
	缺点是使代码复杂化，破坏数据，保存线程状态需要内存消耗，线程调度需要CPU占用


2、iOS的多线程方案有哪几种？你更倾向于哪一种？
	NSThread,GCD,NSOperation
	倾向于GCD,NSOperation,GCD可以充分利用设备的多核提高性能。NSOperation是对GCD的封装，使用起来更加面向对象。


3、你在项目中用过 GCD 吗？
	经常使用
	GCD有两种执行方式同步异步dispatch_sync,dispatch_async
	GCD有两种队列，串行队列并发队列
	GCD还有队列组的使用，一次执行代码dispatch_once,延迟执行dispatch_after,
	GCD还有dispatch_barrier_sync,dispatch_barrier_async
	GCD还有dispatch_semaphore


4、GCD 的队列类型
	串行队列、并发队列，还封装了主队列和全局并发队列


5、说一下 OperationQueue 和 GCD 的区别，以及各自的优势
	GCD使用起来更灵活，效率更高，NSOperationQueue是对GCD的封装，使用更加面向对象化，接口简单
	NSOperationQueue提供了一些实用的功能，比如最大并发数的设置，队列的挂起和取消，任务间的依赖关系
	NSOperation 是一个抽象类，常用的两个类是 NSInvocationOperation 和 NSBlockOperation 。
	我们也可以继承自定义，GCD没有继承复用度不高。
	NSOperation还可以获取自身目前的状态是否执行是否取消
	NSOperation还可以设置优先级
	

	
6、线程安全的处理手段有哪些？
	使用信号量：dispatch_semphore
	使用GCD的串行队列：dispatch_queue_t  serier
	使用锁：
		NSLock
		@synchronized{}
		NSConditionLock


7、OC你了解的锁有哪些？在你回答基础上进行二次提问；

	自旋锁和互斥锁
		自旋锁
			OSSPinLock
		互斥锁
			pthread_mutex
			NSLock
			NSCondition
			NSConditionLock

	追问一：自旋和互斥对比？
		自旋锁会忙等
		互斥锁会是线程休眠


追问二：使用以上锁需要注意哪些？
	获取锁和释放锁的平衡
	不同的线程使用的是同一把锁，否则无法起到同步的作用



追问三：用C/OC/C++，任选其一，实现自旋或互斥？口述即可！
	如果判断到已加锁，调用系统函数将当前线程阻塞，这是互斥锁
	还有一种是一直循环判断lock状态，如果lock=0接着循环，如果lock=1跳出循环继续执行就是自旋锁
	互斥锁会释放线程占用的cpu资源去执行别的线程，但线程状态的保存和线程调度也会占用资源，所以短时间的占用锁用自旋锁，长时间的占用锁用互斥锁
```


<!-- ************************************************ -->
## <a id="content5">5 Interview For Runtime</a>

```
1、使用CADisplayLink、NSTimer有什么注意点？
	CADisplayLink、NSTimer会对target产生强引用，如果target又对它们产生强引用，那么就会引发循环引用
		使用block
		使用proxy
	NSTimer依赖于RunLoop，如果RunLoop的任务过于繁重，可能会导致NSTimer不准时
		GCD的定时器会更加准时



2、介绍下内存的几大区域
	代码段：编译之后的代码
	数据段
		常量区：字符串常量
		已初始化数据：全局变量，静态局部变量
		未初始化数据：全局变量，静态局部变量
	堆区：动态分配的空间
	栈区：函数调用开辟的空间
	内核区

3、讲一下你对 iOS 内存管理的理解
	内存管理主要有两点
		引用计数
			创建并持有对象，引用计数加1
			持有对象，引用计数加1
			释放对象，引用计数减1
			销毁对象，引用计数为0时销毁对象
			只不过在ARC环境下，不需要我们自己管理引用计数
		自动释放池
			放入自动释放池的对象不会立马释放，而是在自动释放池销毁时统一释放
			为防止自动释放池占用内存过大，runloop持有并管理自动释放池的创建于销毁

4、ARC 都帮我们做了什么？
	
	ARC帮我们管理对象的引用计数，而不用我们再手动键入release和retain操作
	帮我们实现了对象的创建，持有，释放和销毁。

	LLVM + Runtime

5、weak指针的实现原理
	__weak 修饰的变量指向对象时不会使对象的引用计数加1
	指向的对象释放后，__weak修饰的变量自动置为nil

6、autorelease对象在什么时机会被调用release
	runloop负责管理自动释放池的创建于销毁。
	在线程被唤醒时创建自动释放池，在线程休眠时销毁自动释放池
	自动释放池在销毁时会对其持有的对象统一进行release


7、方法里有局部对象， 出了方法后会立即释放吗
	alloc,malloc,copy,mutableCopy创建的对象作为函数返回值时，会被注册到自动释放池，不会立即释放
	非alloc,malloc,copy,mutableCop方法返回的对象也会被注册到自动释放池，不会立即释放

```


<!-- ************************************************ -->
## <a id="content6">6 Interview For Runtime</a>

```

1、你在项目中是怎么优化内存的？

2、优化你是从哪几方面着手？

3、列表卡顿的原因可能有哪些？你平时是怎么优化的？

4、遇到tableView卡顿嘛？会造成卡顿的原因大致有哪些？


```



<!-- ************************************************ -->
## <a id="content7">7 Interview For Runtime</a>

```

1、讲讲 MVC、MVVM、MVP，以及你在项目里具体是怎么写的？

2、你自己用过哪些设计模式？

3、一般开始做一个项目，你的架构是如何思考的？
```



----------
>  行者常至，为者常成！


