---
layout: post
title: "暂存3"
date: 2017-01-09
tag: Objective-C
---




## 目录
* [《招聘一个靠谱的 iOS》— 参考答案（下）](#content1)


<!-- ************************************************ -->
## <a id="content1">《招聘一个靠谱的 iOS》— 参考答案（下）</a>

```

25. _objc_msgForward函数是做什么的，直接调用它将会发生什么？

	消息机制涉及下面几个步骤：
		1.消息发送
			在当前类或父类的类对象中查找方法实现
		2.动态方法解析
			动态的为当前类添加方法
		3.消息转发
			尝试找到一个能响应该消息的对象，转发给它
			如果找不到就进行自定义处理
				获取方法签名，包装成NSInvocation,自定义处理

		4.如果以上都没有实现，就会抛错，方法为找到

	_objc_msgForward 做的事情就是上边的第2-4步骤

	如果直接调用，会跳过消息发送阶段，进行2，3，4步骤。即使该类实现了方法，也不会进行查找了



26. runtime如何实现weak变量的自动置nil？

	见 第 10 题



27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？

	不能向编译后得到的类中增加实例变量；
		编译后的类已经注册到runtime中，实例变量的内存大小，成员变量分布，已经确定

	能向运行时创建的类中添加实例变量；
		调用 class_addIvar 函数可以添加变量
		但是得在调用 objc_allocateClassPair 之后，objc_registerClassPair 之前，原因同上。


28. runloop和线程有什么关系？
	runloop和线程是一对一的关系，RunLoop保存在一个全局的Dictionary里，线程作为key，RunLoop作为value
	runloop它可以管理线程，让线程该工作的时候工作，该休眠时休眠
	runloop可以让线程持续运行，它是一个事件处理循环，用来不停的调度工作和处理输入事件
	主线程的runloop是默认开启的，它保证了程序的不退出
	子线程的runloop默认是关闭的，在第一次获取它的时候会开启。
		如果需要更多的与子线程交互可以使用runloop
		如果线程只是执行一个比较长时间的任务则不需要


29. runloop的mode作用是什么？
	mode包括以下成员
		name
		source0：触摸事件
		source1：线程间通讯
		timers：定时器事件
		observers：监听runloop状态

	常见的mode有：NSDefaultRunLoopMode，UITrackingRunLoopMode

	runloop只能运行在一个mode下，所以每次运行runloop都要指定一个mode，
	当切换mode时需要退出当前loop，重新选择mode再进入
	mode的作用是只有和该mode相关的source和事件才会被传递和监听，可以起到隔绝的作用
		比如定时器工作在NSDefaultRunLoopMode，tableView滑动时工作在UITrackingRunLoopMode，这是定时器就会停止工作


30. 以+ scheduledTimerWithTimeInterval...的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？
	RunLoop只能运行在一种mode下，如果要换mode，当前的loop也需要停下重启成新的。
	定时器默认只能工作在NSDefaultRunLoopMode下，页面滑动时runloop会切换到UITrackingRunLoopMode下，timer会暂停回调
	解决办法是，将timer添加到UITrackingRunLoopMode模式下。



31. 猜想runloop内部是如何实现的？

	一般线程只能执行一个任务，执行完毕线程退出。如果我们需要线程保活就可以使用runloop,runloop是靠循环来驱动的伪代码如下

int main(int argc, char * argv[]) {
 //程序一直运行状态
 while (AppIsRunning) {
      //睡眠状态，等待唤醒事件
      id whoWakesMe = SleepForWakingUp();

      //得到唤醒事件
      id event = GetEvent(whoWakesMe);

      //开始处理事件
      HandleEvent(event);
 }
 return 0;
}


32. objc使用什么机制管理对象内存？

	通过引用计数retainCount来管理对象的内存

	在MRC下通过下面四种方式来管理一个对象的内存
		创建并持有对象：alloc new copy mutableCopy 会让引用计数加1
		持有对象：retain	引用计数加1
		释放对象：release 引用计数减1
		销毁对象：dealloc	引用计数为0对象销毁

	同时需要遵循几个原则
		自己创建的对象自己持有，
		非自己创建的对象也可以持有，
		不能释放非自己持有的对象

	另外为了更好的管理对象还引入了自动释放池，放入自动释放池的对象不会立即销毁，而是在离开自动释放池的作用域时统一销毁
	在ARC下，原理同上一样，只是不需要我们自己进行手动管理了

	

33. ARC通过什么方式帮助开发者管理内存？

	ARC在编译期和运行期两部分共同帮助开发者管理内存
	在编译时添加retain/release/autorelease，用的是更底层的C接口实现，这样做性能更好，同时对同一上下文成对的retain/release进行优化，去除不必要的操作
	在运行期同样做了优化



34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）

	分两种情况：手动干预释放时机、系统自动去释放。
		手动干预释放时机--指定 autoreleasepool 就是所谓的：当前作用域大括号结束时释放。

		系统自动去释放--不手动指定 autoreleasepool
			__autoreleasing 修饰的 autorelease 对象，会被添加到最近一次创建的自动释放池中
			当前runloop迭代结束时执行pop函数释放
			runloop启动时创建自动释放池，runloop迭代结束时自动释放池释放autorelease对象并销毁

			所有 autorelease 的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中。

			如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。
				分析：view加载完成后一个运行循环结束，自动释放池释放autorelease对象并销毁。
				在view显示之前线程就会开始等待用户的操作，等待启动新的运行循环创建新的自定释放池

35. BAD_ACCESS在什么情况下出现？
	
	对一个已经释放的对象执行了release
	访问已经释放对象的成员变量或者发消息
	死循环



36. 苹果是如何实现autoreleasepool的？

	AutoreleasePool 是以 AutoreleasePoolPage 为节点的双向链表来实现的，主要通过下列三个函数完成：
        1. objc_autoreleasepoolPush
        2. objc_autoreleasepoolPop
        3. objc_autorelease
	看函数名就可以知道，对 autorelease 分别执行 push，和 pop 操作。销毁对象时执行release操作。




37. 使用block时什么情况会发生引用循环，如何解决？

	对象中强引用了 block，在 block 中又强引用了该对象，就会发生循环引用
	对象使用 __weak 修饰符修饰之后再在 block 中使用
	对象使用unsafe_unretained修饰，但存在安全问题
	可以使用 __block，但不推荐这种做法


38. 在block内如何修改block外部变量？

	外部变量使用__block修饰
	__block修饰的变量在编译阶段会被包装成一个对象，对象内部有一个成员变量存储着原变量的值
	block会对该对象进行捕获，block内修改的值就是捕获对象内部的成员变量的值，
	所以在内部可以进行修改，并且也可以在外部访问


39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？





40. GCD的队列（dispatch_queue_t）分哪两种类型？
1. 串行队列Serial Dispatch Queue
2. 并发队列Concurrent Dispatch Queue


41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）
使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
dispatch_group_async(group, queue, ^{ /*加载图片1 */ });
dispatch_group_async(group, queue, ^{ /*加载图片2 */ });
dispatch_group_async(group, queue, ^{ /*加载图片3 */ }); 
dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        // 合并图片
});



42. dispatch_barrier_async的作用是什么？
在并发队列中，为了保持某些任务的顺序，需要等待一些任务完成后才能继续进行，使用 barrier 来等待之前任务完成，避免数据竞争等问题。
（注意：使用 dispatch_barrier_async ，该函数只能搭配自定义并发队列 dispatch_queue_t 使用。不能使用： dispatch_get_global_queue ，否则 dispatch_barrier_async 的作用会和 dispatch_async 的作用一模一样。 ）


43. 苹果为什么要废弃dispatch_get_current_queue？

	dispatch_get_current_queue容易造成死锁



44. 以下代码运行结果如何？
   - (void)viewDidLoad {
       [super viewDidLoad];
       NSLog(@"1");
       dispatch_sync(dispatch_get_main_queue(), ^{
           NSLog(@"2");
       });
       NSLog(@"3");
   }
只输出：1 。发生主线程锁死。




45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？
// 添加键值观察
/*
1 观察者，负责处理监听事件的对象
2 观察的属性
3 观察的选项
4 上下文
*/
[self.person addObserver:self forKeyPath:@"name" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@"Person Name"];
observer中需要实现一下方法：
// 所有的 kvo 监听到事件，都会调用此方法
/*
 1. 观察的属性
 2. 观察的对象
 3. change 属性变化字典（新／旧）
 4. 上下文，与监听的时候传递的一致
 */
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context;



46. 如何手动触发一个value的KVO

willChangeValueForKey: 和 didChangevlueForKey:


47. 若一个类有实例变量 NSString *_foo ，调用setValue:forKey:时，可以以foo还是 _foo 作为key？
都可以。




48. KVC的keyPath中的集合运算符如何使用？
1. 必须用在集合对象上或普通对象的集合属性上
2. 简单集合运算符有@avg， @count ， @max ， @min ，@sum，
3. 格式 @"@sum.age"或  @"集合属性.@max.age"

https://www.jianshu.com/p/aef6b3a3f87a

https://www.jianshu.com/p/c8198d24ac6f


49. KVC和KVO的keyPath一定是属性么？

KVC 支持属性,支持实例变量，
KVO 支持属性,支持实例变量,但实例变量的kvo监听需要手动实现

// 手动设定KVO
- (void)setAge:(NSString *)age{
    [self willChangeValueForKey:@"age"];
    _age = age;
    [self didChangeValueForKey:@"age"];
}

- (NSString *)age{
    return _age;
}

+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key{
    // 如果监测到键值为age,则指定为非自动监听对象
    if ([key isEqualToString:@"age"]){
        return NO;
    }
    
    return [super automaticallyNotifiesObserversForKey:key];
}

https://developer.aliyun.com/article/30483


50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？
请参考：
1. 《如何自己动手实现 KVO》
2. KVO for manually implemented properties

动态创建一个新的kvo_notify中间类
	让其继承自被监听对象的类对象
	动态添加setter方法


让被监听对象的isa指向这个中间类的类对象




https://tech.glowing.com/cn/implement-kvo/



51. apple用什么方式实现对一个对象的KVO？




52. IBOutlet连出来的视图属性为什么可以被设置成weak?
因为既然有外链那么视图在xib或者storyboard中肯定存在，视图已经对它有一个强引用了。
不过这个回答漏了个重要知识，使用storyboard（xib不行）创建的vc，会有一个叫_topLevelObjectsToKeepAliveFromStoryboard 的私有数组强引用所有 top level 的对象，所以这时即便 outlet 声明成weak也没关系


53. IB中User Defined Runtime Attributes如何使用？
它能够通过KVC的方式配置一些你在interface builder 中不能配置的属性。当你希望在IB中作尽可能多得事情，这个特性能够帮助你编写更加轻量级的viewcontroller


54. 如何调试BAD_ACCESS错误



55. lldb（gdb）常用的调试命令？
* breakpoint 设置断点定位到某一个函数
* n 断点指针下一步
* po打印对象

```



----------
>  行者常至，为者常成！


