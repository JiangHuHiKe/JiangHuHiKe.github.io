---
layout: post
title: "drawRect"
date: 2017-06-03
tag: Objective-C
---





## 目录
* [官方文档](#content1)
* [调用时机](#content2)
* [刷新标记](#content3)



<!-- ************************************************ -->
## <a id="content1">官方文档</a>

在传入的矩形内绘制接收者的图像。


参数
矩形
需要更新的视图边界的部分。第一次绘制视图时，这个矩形通常是视图的整个可见边界。然而，在随后的绘图操作中，矩形可能只指定视图的一部分。

讨论

这个方法的默认实现什么也不做。

使用Core Graphics和UIKit等技术来绘制视图内容的子类应该覆盖这个方法并在那里实现它们的绘制代码。


如果视图以其他方式设置其内容，则不需要重写此方法。例如，如果你的视图只是显示一个背景颜色，或者你的视图直接使用底层对象设置它的内容，你就不需要重写这个方法。


当这个方法被调用时，UIKit已经为你的视图配置了适当的绘图环境，你可以简单地调用任何你需要渲染你的内容的绘图方法和函数。
具体来说，UIKit创建并配置一个用于绘图的图形上下文，并调整该上下文的转换，使其原点与视图边界矩形的原点匹配。
您可以使用UIGraphicsGetCurrentContext函数获得对图形上下文的引用，但不要建立对图形上下文的强引用，因为它可以在调用drawRect:方法之间更改。

同样,如果你画使用OpenGL ES和GLKView类,GLKit配置底层OpenGL ES上下文适当视图之前调用该方法(或GLKView:图形:方法GLKView委托),所以您可以简单地问题无论OpenGL ES命令你需要使你的内容。
有关如何使用OpenGL ES绘图的更多信息，请参阅OpenGL ES编程指南。


您应该将任何绘图限制在rect参数中指定的矩形内。此外，如果视图的opaque属性被设置为YES，那么drawRect:方法必须用opaque内容完全填充指定的矩形。

如果你直接子类化UIView，这个方法的实现不需要调用super。但是，如果你在子类化一个不同的视图类，你应该在实现的某个点调用super。

当视图首次显示或发生使视图可见部分失效的事件时，将调用此方法。你不应该直接调用这个方法。要使视图的一部分无效，并因此导致该部分被重绘，请调用setNeedsDisplay或setNeedsDisplayInRect:方法。



<!-- ************************************************ -->
## <a id="content2">调用时机</a>

当视图首次显示或发生使视图可见部分失效的事件时，将调用此方法。


<!-- ************************************************ -->
## <a id="content3">刷新标记</a>

调用setNeedsDisplay或setNeedsDisplayInRect:方法。

不会立即重绘,而是在下一个绘制周期进行重绘.


----------
>  行者常至，为者常成！


