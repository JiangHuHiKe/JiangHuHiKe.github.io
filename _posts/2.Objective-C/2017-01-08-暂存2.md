---
layout: post
title: "暂存2"
date: 2017-01-08
tag: Objective-C
---




## 目录
* [《招聘一个靠谱的 iOS》— 参考答案（上）](#content1)


<!-- ************************************************ -->
## <a id="content1">《招聘一个靠谱的 iOS》— 参考答案（上）</a>

```

1. 风格纠错题

enum 建议使用 NS_ENUM 和 NS_OPTIONS 

建议使用Foundation中定义的类型
int -> NSInteger
 unsigned -> NSUInteger
 float -> CGFloat
 动画时间 -> NSTimeInterval

业务逻辑都不应当写在 Model 里：MVC 应在 C，MVVM 应在 VM。

init方法命名规范
类方法命名规范
instancetype的使用


@property (nonatomic, readwrite, copy) NSString *name;
原子性，读写性，内存管理
copy的作用，为什么用copy

驼峰命名和下划线命名不要交叉使用


2. 什么情况使用 weak 关键字，相比 assign 有什么不同？

在有可能出现循环引用的时候，需要其中一方使用weak
IBOutlet连出来的视图属性使用weak

weak对应的权限修饰符是__weak，当weak修饰的变量指向一个对象时，不会使其引用计数加1，当对象销毁时weak修饰的变量会被赋值为nil
Assign对应的权限修饰符是__unsafe_unretained，同样也不会改变指向对象的引用计数，也不会自动赋值为nil。另外Assign也只是修饰基本类型



3. 怎么用 copy 关键字？

用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为它们有对应的可变类型。防止可变类型改变时，影响我们之前的赋值，所以使用copy获得一份不可变类型的对象。
block使用copy时MRC遗留过来的，目的是将在栈上的block拷贝到堆上。ARC下block使用copy或strong是一样的，blcok赋值给strong修饰的变量时系统会进行拷贝



4. 这个写法会出什么问题： @property (copy) NSMutableArray *array;

原子性默认是atomic，atomic属性会严重影响性能
当数组对元素进行增加，删除，修改时会报找不到方法的错误，原因就是使用了copy修饰符，copy会返回一个不可变对象


5. 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？

让自己的类遵守并实现NSCopying协议

- (void)setName:(NSString *)name {
    //[_name release];
    _name = [name copy];
}


6. @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的

@property = ivar + getter + setter;
可以将property看做是一个关键字，编译器在编译阶段会为我们生成带下划线的成员变量，getter方法，setter方法，这是一个自动合成的过程


7. @protocol 和 category 中如何使用 @property

在 protocol 中使用 property 只会生成 setter 和 getter 方法声明，遵守协议的对象需要实现该属性
category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果要给 category 增加属性我们可以使用关联对象。


8. runtime 如何实现 weak 属性

weak修饰的变量，不会使指向的对象的引用计数加1，当指向的对象销毁时，变量会被赋值为nil，当向其发送消息时不会引起崩溃
用weak变量指向的对象的内存地址作为key，所有指向该对象的weak变量放入list作为value，放入hash表，当对象的引用计数变为0时，通过key找到列表，将列表内的变量赋值为nil



9. @property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？

原子性：atomic / nonatomic 
读写权限：readwrite / readonly
内存管理语义：assign weak strong copy unsafe_unretained
方法名：getter=<name>,setter=<name> 
	getter的样式：@property (nonatomic, getter=isOn) BOOL on;


10. weak属性需要在dealloc中置nil么？

不需要。

weak 不会使引用计数加1，weak变量指向的对象销毁时，会自动被赋值nil。
weak变量指向的对象的内存地址做为key，所有指向该对象的weak变量列表作为value，
当对象被销毁时，通过key找到列表，对列表中的变量赋值为nil，
所以不需要手动置为nil


11. @synthesize和@dynamic分别有什么作用？

@property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是@syntheszie var = _var;
@synthesize是告知编译器生成setter方法、getter方法、_var成员变量
@dynamic是告知编译器不生成setter方法、getter方法、_var成员变量，用户手动实现


12. ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？

原子性：atomic（默认） / nonatomic 
读写权限：readwrite（默认） / readonly
内存管理语义：assign（基本类型默认） weak  strong（对象类型默认） copy unsafe_unretained



13. 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？

1. 因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.
2. 如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.



14. @synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？


@synthesize ivar = _ivar； 会自动生成_ivar成员变量
@synthesize ivar；会自动生成ivar成员变量
不书写默认是@synthesize ivar = _ivar；

假如property名为foo,并且存在_foo
如果保持默认 或 @synthesize foo = _foo；不会自动合成新变量
如果是@synthesize foo；会自动合成foo成员变量


15. 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？

回答这个问题前，我们要搞清楚一个问题，什么情况下不会autosynthesis（自动合成成员变量）？
1. 同时重写了 setter 和 getter 时
2. 重写了只读属性的 getter 时
3. 使用了 @dynamic 时
4. 在 @protocol 中定义的所有属性
5. 在 category 中定义的所有属性
6. 重写（overridden）的属性


同时重写了 setter 和 getter 时需要使用@synthesize
重写了只读属性的 getter 时
重写了父类的属性时



16. objc中向一个nil对象发送消息将会发生什么？

在 Objective-C 中向 nil 发送消息是完全有效的，只是在运行时不会有任何作用:会返回nil或0
objc向一个对象发送消息时，runtime库会根据对象的isa指针找到对象的类对象，在类对象的方法列表中寻找要调用的方法。如果是向nil发送消息，在寻找对象的isa指针时就会返回nil或0，不会有任何报错


17. objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？

[obj foo];在objc编译时，会被转意为：objc_msgSend(obj, @selector(foo));。
obj是消息的接收者，@selector(foo)是方法名，是发送的消息
通过obj的isa指针可以找到obj所属的类对象，通过方法名在类对象的方法列表内找到方法调用。


18. 什么时候会报unrecognized selector的异常？

实例对象调用方法要经过三个步骤
1.消息发送
该阶段主要是根据发送的消息在类对象的方法列表内查找方法，如果没找到就进入动态方法解析阶段

2.动态方法解析
该阶段的主要任务是，为该对象动态添加可调用的方法，然后重新走消息发送阶段

3.消息转发
经过以上两个过程仍未找到要调用的方法，会来到消息转发，在该阶段可以将消息转发到其它的对象，也可以进行自定义的处理。如果既没有转发给其它对象，也没有进行自定义处理，那么就会报unrecognized selector异常



19. 一个objc对象如何进行内存布局？（考虑有父类的情况）
isa指针（指向类对象）
父类的成员变量的值
当前类的成员变量的值

- - - isa
—— super

rootInstance		rootClass			rootMeta		

superInstance		superClass		superMeta
	
subInstance		subClass			subMeta


20. 一个objc对象的isa的指针指向什么？有什么作用？

isa 指向当前类的类对象，同一个类的不同实例对象的isa指向的类对象是同一个
通过isa找到类对象，类对象存储了当前类的方法列表，属性列表，协议列表等信息。当objc调用方法时，对属性值存取时，都是isa在起作用。


21. 下面的代码输出什么？

@implementation Son : Father
   - (id)init{
       self = [super init];
       if (self) {
           NSLog(@"%@", NSStringFromClass([self class]));
           NSLog(@"%@", NSStringFromClass([super class]));
       }
       return self;
   }
   @end

都输出son
super消息的接收者仍是当前类对象，super的含义不是调用父类的class方法，而是从父类的方法列表中开始去查找实现
[self class] : objc_msgSend(id self, SEL)
[super class] : objc_msgSendSuper(objc_super * super ,SEL)
objc_super {
	id receiver
	Class super_class
}



22. runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）

每一个类对象中都有一个方法列表，方法列表中记录着方法的名称，参数类型，方法实现IMP，selector就是方法名，通过方法名就可以找到方法实现
同理每一个元类对象也有一个方法列表，该列表中记录着类方法的相关内容
- (IMP)methodForSelector:(SEL)aSelector;
+ (IMP)instanceMethodForSelector:(SEL)aSelector;


23. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？

无论在MRC下还是ARC下均不需要。
对象的销毁分为四个步骤
1.调用 -release引用计数减少
2.子类调用 -dealloc
3.NSObject 调用 -dealloc
4.调用 object_dispose
	在这里释放runtime Associate方法关联的对象


24. objc中的类方法和实例方法有什么本质区别和联系？

类方法：
1. 类方法是属于类对象的
2. 类方法只能通过类对象调用
3. 类方法中的self是类对象
4. 类方法可以调用其他的类方法
5. 类方法中不能访问成员变量
6. 类方法中不能直接调用对象方法


实例方法：
1. 实例方法是属于实例对象的
2. 实例方法只能通过实例对象调用
3. 实例方法中的self是实例对象
4. 实例方法中可以访问成员变量
5. 实例方法中直接调用实例方法
6. 实例方法中也可以调用类方法(通过类名)

```

----------
>  行者常至，为者常成！


