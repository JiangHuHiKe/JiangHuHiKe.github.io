---
layout: post
title: "符号表"
date: 2021-01-04
tag: Objective-C
---






## 目录
- [nm命令](#content1)   
- [在xcconfig文件内配置](#content2)   
- [符号的可见性](#content3)   
- [swiftc命令](#content4)   
- [objdump命令](#content5)   


 





<!-- ************************************************ -->
## <a id="content1">nm命令</a>

**查看某个命令的使用**

```
方式一:
man nm

方式二:
nm --help

nm --help | grep 
```

**nm --help命令**

```
╰─○ nm --help
OVERVIEW: llvm symbol table dumper

USAGE: nm [options] <input files>

OPTIONS:

Generic Options:

  --help             - Display available options (--help-hidden for more)
  --help-list        - Display list of available options (--help-list-hidden for more)
  --version          - Display the version of this program

llvm-nm Options:

  -B                 - Alias for --format=bsd
  -P                 - Alias for --format=posix
  --add-dyldinfo     - Add symbols from the dyldinfo not already in the symbol table, Mach-O only

...

```

**nm --version**

```
╰─○ nm --version
Apple LLVM version 12.0.5 (clang-1205.0.22.11)
  Optimized build.
  Default target: x86_64-apple-darwin20.5.0
  Host CPU: broadwell
```


**nm -pa inputfiles**

```
// -p : 不排序
// -a : 显示所有符号,包括调试符号

╰─○ nm -pa machoinfo 
0000000100001020 t _read_magic
0000000100001080 t _is_magic_64
00000001000010b0 t _should_swap_bytes
0000000100001100 t _is_fat
0000000100001130 t _dump_fat_header
...

```


<!-- ************************************************ -->
## <a id="content2">在xcconfig文件内配置</a>

**.xcconfig文件**

```
//1.
//解决xcconfig文件的冲突
#include "../../../Pods/Target Support Files/Pods-LCClientDemo/Pods-LCClientDemo.debug.xcconfig"


//2.
// -p : 不排序
// -a : 显示所有符号,包括调试符号
MACHO_PATH=${BUILD_DIR}/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)/LCClientDemo.app/LCClientDemo
CMD = nm
CMD_FLAG = -pa ${MACHO_PATH}
TTY = /dev/ttys002


//3.
//$(inherited) 继承之前的设定,解决冲突
//Xlinker 传给连接器的参数
//查看连接器参数:man ld 然后输入 / -S
//-S  Do not put debug information (STABS or DWARF) in the output file.
OTHER_LDFLAGS = $(inherited) -Xlinker -S


//4.
//设置条件
OTHER_LDFLAGS[config=Debug][sdk=iphonesimulator*][arch=x86_64] = $(inherited) -framework "Cat"


//5.
//解决 // 问题
//URL_TEST = http://127.0.0.1
FLASH = /
URL_TEST = http:${FLASH}/127.0.0.1

```

**Build Phases -> Run Script**

```
/bin/sh "$SRCROOT/LCClientDemo/Script/xcode_run_cmd.sh"
```

**xcode_run_cmd.sh**

```
#!/bin/sh


RunCommand() {
  #判断全局字符串VERBOSE_SCRIPT_LOGGING是否为空。-n string判断字符串是否非空
  #[[是 bash 程序语言的关键字。用于判断
  if [[ -n "$VERBOSE_SCRIPT_LOGGING" ]]; then
    #作为一个字符串输出所有参数。使用时加引号"$*" 会将所有的参数作为一个整体，以"$1 $2 … $n"的形式输出所有参数
      if [[ -n "$TTY" ]]; then
          echo "♦ $@" 1>$TTY
      else
          echo "♦ $*"
      fi
      echo "------------------------------------------------------------------------------" 1>$TTY
  fi
  #与$*相同。但是使用时加引号，并在引号中返回每个参数。"$@" 会将各个参数分开，以"$1" "$2" … "$n" 的形式输出所有参数
  if [[ -n "$TTY" ]]; then
      echo `$@ &>$TTY`
  else
      "$@"
  fi
  #显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。
  return $?
}

EchoError() {
    #在shell脚本中，默认情况下，总是有三个文件处于打开状态，标准输入(键盘输入)、标准输出（输出到屏幕）、标准错误（也是输出到屏幕），它们分别对应的文件描述符是0，1，2
    # >  默认为标准输出重定向，与 1> 相同
    # 2>&1  意思是把 标准错误输出 重定向到 标准输出.
    # &>file  意思是把标准输出 和 标准错误输出 都重定向到文件file中
    # 1>&2 将标准输出重定向到标准错误输出。实际上就是打印所有参数已标准错误格式
    if [[ -n "$TTY" ]]; then
        echo "$@" 1>&2>$TTY
    else
        echo "$@" 1>&2
    fi
    
}

RunCMDToTTY() {
    if [[ ! -e "$TTY" ]]; then
        EchoError "=========================================="
        EchoError "ERROR: Not Config tty to output."
        exit -1
    fi
    
    if [[ -n "$CMD" ]]; then
        RunCommand "$CMD" ${CMD_FLAG}
    else
        EchoError "=========================================="
        EchoError "ERROR:Failed to run CMD. THE CMD must not null"
    fi
}


RunCMDToTTY

```


<!-- ************************************************ -->
## <a id="content3">符号的可见性</a>


**符号可见性**

-O1 -Oz 生成目标文件时 在编译阶段的处理

dead code strip 死代码剥离 在链接阶段处理

strip 剥离符号 mach-O修改 (deployment postprocessing 设置为yes)


**xcode设置strip**

1  找到下面的设置组   

Build Settings -> Deployment 


2  找到下面的设置项,设置为YES    

Deployment PostProcessing 设置为 YES     


3  找到下面的设置项进行配置

Strip style 的类型选择

All Symbols      
Non-Global Symbols     
Debugging Symbols     


 


<!-- ************************************************ -->
## <a id="content4">swiftc命令</a>

**swiftc --help命令**

```
╰─○ swiftc --help
OVERVIEW: Swift compiler

USAGE: swiftc

MODES:
  -dump-ast              Parse and type-check input file(s) and dump AST(s)
  -dump-parse            Parse input file(s) and dump AST(s)
  -dump-pcm              Dump debugging information about a precompiled Clang module
  ...
```

**swiftc --help命令过滤**
```
╰─○ swift --help | grep -- "-D"
  -D <value>              Marks a conditional compilation flag as true
```


<!-- ************************************************ -->
## <a id="content5">objdump命令</a>

**查看mach header**

```
╰─○ objdump --help | grep -- "--macho"
  -m                               - Alias for --macho
  --macho                          - Use MachO specific object file parser


╰─○ objdump --help | grep -- '--private-header' 
  --private-header                 - Display only the first format specific file header
  -p                               - Alias for --private-headers
  --private-headers                - Display format specific file headers


╰─○ objdump --macho --private-header MachOAndSymbol
Mach header
      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64  X86_64        ALL  0x00     EXECUTE    20       1960   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE
```

**查看反汇编**

```
╰─○ objdump --help | grep -- '-d'
  -d                               - Alias for --disassemble


╰─○ objdump --macho -d MachOAndSymbol
MachOAndSymbol:
(__TEXT,__text) section
_main:
100003ec0:	55	pushq	%rbp
100003ec1:	48 89 e5	movq	%rsp, %rbp
...
_weak_import_function:
100003f00:	55	pushq	%rbp
100003f01:	48 89 e5	movq	%rsp, %rbp
...
_weak_function:
100003f20:	55	pushq	%rbp
100003f21:	48 89 e5	movq	%rsp, %rbp
...
_weak_hidden_function:
100003f40:	55	pushq	%rbp
100003f41:	48 89 e5	movq	%rsp, %rbp
...
```


```
0203 链接与符号表

.o目标文件 -> 此时地址并未虚拟化

1. 汇编
2. 符号归类 -> 放入重定位符号表

归类:
代码放入代码段
数据放入数据段
NSLog不存在当前的macho,而是存在于其它的macho,在链接的过程中才会确定一些东西

以上需要放在一个地方暂存起来


3. 重定位符号表 内放置的是当前 .m/.o 用到的API(.o需要链接,才能变为可执行文件)


查看重定位符号表
objdump --macho -reloc xx.o文件

通过查看重定位符号表,就可以知道当前.o文件调用了哪些api.

4. 多个.o文件 -> 链接 -> 可执行文件

符号表 合并到 一张表 中
重定位符号表  合并到 一张表中

总结:链接的过程就是处理.o文件中符号的过程
```


```
0204 全局和本地符号

一. 全局符号 与 本地符号

全局变量在符号表里全都是全局符号
g:代表全局符号
l:代表本地符号



╰─○ objdump --help | grep -- '--syms'
  --syms                           - Display the symbol table
  -t                               - Alias for --syms



╰─○ objdump --macho -syms MachOAndSymbol1
MachOAndSymbol1:
SYMBOL TABLE:
0000000100000000 g     F __TEXT,__text __mh_execute_header
0000000100003fa0 g     F __TEXT,__text _main
0000000000000000         *UND* dyld_stub_binder



╰─○ objdump --macho -syms MachOAndSymbol2 
MachOAndSymbol2:
SYMBOL TABLE:
0000000100008008 l     O __DATA,__data __dyld_private
0000000100008010 l     O __DATA,__data _global_init_value
0000000100008014 l     O __DATA,__data _static_init_value
0000000100008018 l     O __DATA,__bss _static_uninit_value
0000000100008028 l     O __DATA,__common _default_x
0000000100000000 g     F __TEXT,__text __mh_execute_header
0000000100008020 g     O __DATA,__common _global_uninit_value
0000000100003f50 g     F __TEXT,__text _main
0000000000000000         *UND* _NSLog
0000000000000000         *UND* ___CFConstantStringClassReference
0000000000000000         *UND* dyld_stub_binder



//全局符号变为本地符号 
double default_x __attribute__((visibility("hidden"))) ;
static int static_init_value = 9;
静态变量 -> 本地变量


全局符号:对当前项目可见对其它项目也可见(对内对外都可见).
比如库A内有一个方法,但并未在头文件内暴露
void global_object () {
  NSLog(@"global_object");
}

在app内引入库A,只声明一个void global_object ()方法并不写实现.
当调用global_object ()时,就会调用到库A内的方法.


//static只对定义它的文件可见,是本地符号
static void global_object () {
  NSLog(@"global_object");
}


two_levelnamespace & flat_namespace:
二级命名空间与一级命名空间。
链接器默认采用二级命名空间，也就是除了会记录符号 名称，还会记录符号属于哪个Mach-O的，
比如会记录下来_NSLog来自Foundation。

```


```
0205 同一文件相同全局符号
同一个mach-o文件内有相同的全局符号,会报错.
```

```
0206 导入导出符号

一. 查看导出符号

我们的APP使用Foundation框架下的NSLog
NSLog对我们的APP来说导入了NSLog
NSLog对Foundation框架来说导出了NSLog


╰─○ objdump --help | grep -- '--exports-trie'
  --exports-trie                   - Display mach-o exported symbols


╰─○ objdump --macho --exports-trie MachOAndSymbol3
MachOAndSymbol3:
Exports trie:
0x100000000  __mh_execute_header
0x100003F50  _main
0x100008014  _lxy_global_value
0x100008020  _global_uninit_value
 
全局符号默认是导出符号,但我们可以通过链接器控制它



二. 间接符号表
动态库 -> 对外提供符号
间接符号表 -> 存储动态库符号

╰─○ objdump --help | grep -- 'indirect-symbols'
  --indirect-symbols               - Print indirect symbol table for Mach-O objects (requires -macho)


╰─○ objdump --macho --indirect-symbols MachOAndSymbol3
MachOAndSymbol3:
Indirect symbols for (__TEXT,__stubs) 1 entries
address            index name
0x0000000100003f90     9 _NSLog
Indirect symbols for (__DATA_CONST,__got) 1 entries
address            index name
0x0000000100004000    11 dyld_stub_binder
Indirect symbols for (__DATA,__la_symbol_ptr) 1 entries
address            index name
0x0000000100008000     9 _NSLog

动态库全局符号 -> 变为导出符号 -> APP的间接符号表
所以动态库的全局符号不能通过 strip 脱掉 


三. 将导出符号变为非导出符号

OTHER_LDFLAGS=$(inherited) -Xlinker -unexported_symbol -Xlinker _OBJC_METACLASS_$_LGOneObject

因为OC的动态性,OC符号不能使用 hidden

将全局符号变为了本地符号,这个时候就可以脱去该符号,减少macho文件的体积

```

```
0207 weak符号表

一. -map参数的使用


二. weak symbol

1. 弱引用符号
__attribute__((weak_import))

//API
//弱引用:找不到符号就返回0
//没有找到符号不调用,找到符号就调用
if (weak_import_function) {
    weak_function();
}

OTHER_LDFLAGS=$(inherited) -Xlinker -U -Xlinker _weak_import_function


//把整个动态库声明为弱引用,当找不到这个库时就不会报错了.

在终端
man ld 
然后查找 -S 或者 -U 代表的具体含义


2. 弱定义符号
__attribute__((weak))
不会影响符号是全局符号(导出符号)
找到一个符号就会忽略其它的符号

```


```
0208 Swift符号

一.  
man ld 
-U的作用

二. re-export

OTHER_LDFLAGS=$(inherited) -Xlinker -alias -Xlinker _NSLog -Xlinker _Cat_log

[re-export] _Cat_log (_NSLog from Foundation)


三. swift符号
swift是静态语言

```


```
0209 strip

一. 

app中哪些符号可以脱掉
本地 + 全局 + 弱定义
间接符号表中的不能脱掉

静态库中
.o合集 + 重定位符号表

只能脱掉调试符号

Debugging Symbols(.o静态库/可执行文件 动态库)
All Symbols 
Non-Global Symbols


二. 就符号的性质来说,使用静态库体积小还是动态库体积小.

静态库的体积小

三. dead code strip
本地符号 + 未调用
导出符号不会被dead code strip 剥离

```


```
0210 llvm-strip

一.
strip style
strip 是在修改macho中的一个内容

 
二.llvm-strip的使用


三.断点信息

br read -f 文件

br list strip

br enable strip

br write -f 文件












```



 




----------
>  行者常至，为者常成！


