---
layout: post
title: "dyld分析"
date: 2019-05-04
description: "dyld分析"
tag: 底层原理
---


<h6>
  版权声明：本文为博主原创文章，未经博主允许不得转载。
  <a target="_blank" href="https://jianghuhike.github.io/1954.html">
  原文地址：https://jianghuhike.github.io/1954.html 
  </a>
</h6>



## 目录
- [什么是dyld](#content1)   
- [dyld加载流程](#content2)   



<!-- ************************************************ -->
## <a id="content1"></a>什么是dyld

dyld(the dynamic link editor)是苹果的动态链接器，是苹果操作系统一个重要组成部分，在系统内核做好程序准备工作之后，交由dyld负责余下的工作。

dyld加载所有的库和可执行文件。


<!-- ************************************************ -->
## <a id="content1"></a>dyld加载流程

**一、程序执行从_dyld_star开始**

在工程任一个类的load方法打断点，看下调用栈
```
(lldb) bt
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 2.1
  * frame #0: 0x00000001024e16e4 LCClientDemo`+[AppDelegate load](self=AppDelegate, _cmd="load") at AppDelegate.m:23:2
    frame #1: 0x00000001a0ef0ecc libobjc.A.dylib`load_images + 736
    frame #2: 0x0000000102a4a0d4 dyld`dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*) + 448
    frame #3: 0x0000000102a5958c dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&, unsigned int, char const*, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 524
    frame #4: 0x0000000102a58308 dyld`ImageLoader::processInitializers(ImageLoader::LinkContext const&, unsigned int, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 184
    frame #5: 0x0000000102a583d0 dyld`ImageLoader::runInitializers(ImageLoader::LinkContext const&, ImageLoader::InitializerTimingList&) + 92
    frame #6: 0x0000000102a4a420 dyld`dyld::initializeMainExecutable() + 216
    frame #7: 0x0000000102a4edb4 dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 4616
    frame #8: 0x0000000102a49208 dyld`dyldbootstrap::start(dyld3::MachOLoaded const*, int, char const**, dyld3::MachOLoaded const*, unsigned long*) + 396
    frame #9: 0x0000000102a49038 dyld`_dyld_start + 56
(lldb) 
```

可以看到函数程序开始是从_dyld_start开始的。

`frame #9: 0x0000000102a49038 dyld_dyld_start + 56`

在lldb调试模式下通过up指令，来到frame #9

```
dyld`_dyld_start:

 bl     0x102a4907c               ; dyldbootstrap::start(dyld3::MachOLoaded const*, int, char const**, dyld3::MachOLoaded const*, unsigned long*)
```
我们看到这样一句汇编代码，就是在frame#9函数内对frame#8函数的调用。

找到dyld的源码看下dyldbootstrap::start的方法实现

```
uintptr_t start(const struct macho_header* appsMachHeader, int argc, const char* argv[], 
				intptr_t slide, const struct macho_header* dyldsMachHeader,
				uintptr_t* startGlue)
{
	// if kernel had to slide dyld, we need to fix up load sensitive locations
	// we have to do this before using any global variables
    slide = slideOfMainExecutable(dyldsMachHeader);
    bool shouldRebase = slide != 0;
#if __has_feature(ptrauth_calls)
    shouldRebase = true;
#endif
    if ( shouldRebase ) {
        rebaseDyld(dyldsMachHeader, slide);
    }

	// allow dyld to use mach messaging
	mach_init();

	// kernel sets up env pointer to be just past end of agv array
	const char** envp = &argv[argc+1];
	
	// kernel sets up apple pointer to be just past end of envp array
	const char** apple = envp;
	while(*apple != NULL) { ++apple; }
	++apple;

	// set up random value for stack canary
	__guard_setup(apple);

#if DYLD_INITIALIZER_SUPPORT
	// run all C++ initializers inside dyld
	runDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple);
#endif

	// now that we are done bootstrapping dyld, call dyld's main
	uintptr_t appsSlide = slideOfMainExecutable(appsMachHeader);
	return dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);
}
```

<span style="color:red">在该方法内完成了slide（ASLR）和rebase(MachO文件的重定向)。</span>


**二、进入dyld:main函数**

这个main函数是dyld的main函数，不是main.m文件内的main函数。

程序启动最关键的函数。

1、配置一些环境变量

2、加载共享缓存库（一开始就判断是否禁用，iOS无法被禁用的）

3、实例化主程序

4、加载动态库（插入库、三方库）

5、链接主程序（符号绑定）

6、最关键的地方：初始化方法

	6.1 经过一系列初始化调用到notifySignle函数

		该函数会执行一个回调

		通过断点调试：该函数是_objc_init初始化的时候赋值的一个函数load_images
			
			load_images里面执行call_load_methods函数

				call_load_methods函数循环调用各个类的load方法

	6.2 doModIntFunction函数

		内部会调用带__atrribute_((constructor))的c函数

	6.3 返回主程序的入口函数。开始进入主程序的main函数。


  



----------
>  行者常至，为者常成！


