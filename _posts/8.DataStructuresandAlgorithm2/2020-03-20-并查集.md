---
layout: post
title: "6、并查集"
date: 2020-03-20
description: ""
tag: 数据结构与算法（二）
---






## 目录

* [并查集（Union Find）](#content1)
* [并查集（Union Find）实现](#content2)
* [并查集（Union Find）优化](#content3)





<!-- ************************************************ -->
## <a id="content1"></a>并查集（Union Find）

**一、需求分析**

假设有n个村庄，有些村庄之间有连接的路，有些村庄之间并没有连接的路

<img src="/images/DataStructurs2/union1.png" alt="img">


设计一个数据结构，能够快速执行2个操作      
查询2个村庄之间是否有连接的路      
连接2个村庄        


数组、链表、平衡二叉树、集合（Set）？  
查询、连接的时间复杂度都是：O(n)     

并查集能够办到查询、连接的均摊时间复杂度都是 O(α(n)) ，α(n) < 5     
并查集非常适合解决这类“连接”相关的问题      



**二、并查集（Union Find）介绍**

并查集也叫作不相交集合（Disjoint Set）

并查集有2个核心操作    
查找（Find）：查找元素所在的集合（这里的集合并不是特指Set这种数据结构，是指广义的数据集合）    
合并（Union）：将两个元素所在的集合合并为一个集合    

有2种常见的实现思路     

1、Quick Find    
✓ 查找（Find） 的时间复杂度：O(1)     
✓ 合并（Union）的时间复杂度：O(n)     

2、Quick Union      
✓ 查找（Find） 的时间复杂度：O(logn)，可以优化至 O(α(n)) ，α(n) < 5    
✓ 合并（Union）的时间复杂度：O(logn)，可以优化至 O(α(n)) ，α(n) < 5    
 

**三、如何存储数据**

假设并查集处理的数据都是整型，那么可以用整型数组来存储数据

<img src="/images/DataStructurs2/union2.png" alt="img">

不难看出     
0、1、3 属于同一集合     
2 单独属于一个集合    
4、5、6、7 属于同一集合    

因此，并查集是可以用数组实现的树形结构（二叉堆、优先级队列也是可以用数组实现的树形结构）




<!-- ************************************************ -->
## <a id="content2"></a>并查集（Union Find）实现


**一、接口定义**

```
/// 检查v1、v2是否属于同一个集合
/// @param v1 元素v1
/// @param v2 元素v2
-(BOOL)isSameWithV1:(int)v1 v2:(int)v2;


/// 查找v所属的集合，返回根节点
/// @param v 元素v
-(int)findV:(int)v;


/// 合并v1、v2所属的集合
/// @param v1 元素v1
/// @param v2 元素v2
-(void)unionWithV1:(int)v1 v2:(int)v2;
```


**二、初始化**

初始化时，每个元素各自属于一个单元素集合

<img src="/images/DataStructurs2/union3.png" alt="img">

```
/// 初始化一个并查集
/// @param capacity 容量
-(instancetype)initWithCapacity:(int)capacity{
    
    self = [super init];
    if (self) {
        self.parents = [NSMutableArray arrayWithCapacity:capacity];
        for (int i = 0; i<capacity; i++) {
            self.parents[i] = @(i);
        }
    }
    return self;
}
```

**三、Quick Find**

1、Quick Find - union

Quick Find 的 union(v1, v2)：让 v1 所在集合的所有元素都指向 v2 的根节点

<img src="/images/DataStructurs2/union4.png" alt="img">

<img src="/images/DataStructurs2/union5.png" alt="img">

2、Quick Find - Find

<img src="/images/DataStructurs2/union6.png" alt="img">

◼ find(0) == 2   
◼ find(1) == 2   
◼ find(3) == 4   
◼ find(2) == 2    

3、代码实现

```
/// 检查v1、v2是否属于同一个集合
/// @param v1 元素v1
/// @param v2 元素v2
-(BOOL)isSameWithV1:(int)v1 v2:(int)v2{
    return [self findV:v1] == [self findV:v2];
}

//时间复杂度：O(1)
-(int)findV:(int)v{
    [self rangeCheck:v];
    
    /**
    * 父节点就是根节点
    */
    return [self.parents[v] intValue];
}


//时间复杂度：O(n)
-(void)unionWithV1:(int)v1 v2:(int)v2{
    int p1 = [self findV:v1];
    int p2 = [self findV:v2];
    if(p1 == p2) return;
    
    /**
    * 将v1所在集合的所有元素，都嫁接到v2的父节点上
    */
    for (int i = 0; i<self.parents.count; i++) {
        if (p1 == [self.parents[i] intValue]) {
            self.parents[i] = @(p2);
        }
    }
}
```


**四、Quick Union**

1、Quick Union - union

Quick Union 的 union(v1, v2)：让 v1 的根节点指向 v2 的根节点

<img src="/images/DataStructurs2/union7.png" alt="img">

<img src="/images/DataStructurs2/union8.png" alt="img">


2、Quick Union - find

<img src="/images/DataStructurs2/union9.png" alt="img">

◼ find(0) == 2    
◼ find(1) == 2     
◼ find(3) == 2     
◼ find(2) == 2    

3、代码实现

```
/**
 * 通过parent链条不断地向上找，直到找到根节点
 * 时间复杂度：O(logn)

 */
-(int)findV:(int)v{
    [self rangeCheck:v];
    while (v != [self.parents[v] intValue]) {
        v = [self.parents[v] intValue];
    }
    return v;
}



/**
 * 将v1的根节点嫁接到v2的根节点上
 * 时间复杂度：O(logn)
 */
-(void)unionWithV1:(int)v1 v2:(int)v2{
    int p1 = [self findV:v1];
    int p2 = [self findV:v2];
    if(p1 == p2) return;
    self.parents[p1] = @(p2);
}
```

<!-- ************************************************ -->
## <a id="content3"></a>并查集（Union Find）优化






----------
>  行者常至，为者常成！


