---
layout: post
title: "4、排序（四）"
date: 2020-03-16
description: ""
tag: 数据结构与算法（二）
---






## 目录

* [快速排序（Quick Sort）](#content1)



<!-- ************************************************ -->
## <a id="content1"></a>快速排序（Quick Sort）


快速排序（Quick Sort）         
1960年由查尔斯·安东尼·理查德·霍尔（Charles Antony Richard Hoare，缩写为C. A. R. Hoare）提出    
昵称为东尼·霍尔（Tony Hoare）    


一、**快速排序 – 执行流程**

① 从序列中选择一个轴点元素（pivot）    
✓ 假设每次选择 0 位置的元素为轴点元素     

② 利用 pivot 将序列分割成 2 个子序列     
✓ 将小于 pivot 的元素放在pivot前面（左侧）     
✓ 将大于 pivot 的元素放在pivot后面（右侧）     
✓ 等于pivot的元素放哪边都可以         

③ 对子序列进行 ① ② 操作       
✓ 直到不能再分割（子序列中只剩下1个元素）       

<img src="/images/DataStructurs2/sort24.png" alt="img">

快速排序的本质     
逐渐将每一个元素都转换成轴点元素      

**二、快速排序的轴点构造**

<img src="/images/DataStructurs2/sort25.png" alt="img">



**三、快速排序的时间复杂度**

<img src="/images/DataStructurs2/sort26.png" alt="img">


在轴点左右元素数量比较均匀的情况下，同时也是最好的情况      
T n = 2 ∗ T n/2 + O n = O(nlogn)     

如果轴点左右元素数量极度不均匀，最坏情况     
T n = T n − 1 + O n = O(n2) 

<span style="color:red">为了降低最坏情况的出现概率，一般采取的做法是</span>       
<span style="color:red">随机选择轴点元素</span>     

最好、平均时间复杂度：O(nlogn)    
最坏时间复杂度：O(n2)     
由于递归调用的缘故，空间复杂度：O(logn)      
属于不稳定排序      



**四、快速排序的实现**

```
/**
 最好、平均时间复杂度：O(nlogn) 最坏时间复杂度：O(n2)
 由于递归调用的缘故，空间复杂度：O(logn)
 */
-(void)sort{
    
    [self sortWithBegin:0 end:(int)self.array.count];
}



/// 快速排序[beigin end)
/// @param begin 起始index
/// @param end 结束index
-(void)sortWithBegin:(int)begin end:(int)end{
    
    //至少需要两个元素
    if(end - begin<2) return;
    
    //找到轴点元素的位置
    int mid = [self pivotIndexWithBegin:begin end:end];
    
    
    //对左半部分进行快速排序
    [self sortWithBegin:begin end:mid];
    
    
    //对有半部分进行快速排序
    [self sortWithBegin:mid+1 end:end];
    
}




/// 返回轴点元素索引[begin end)
/// @param begin 起始索引
/// @param end 终止索引
-(int)pivotIndexWithBegin:(int)begin end:(int)end{
    
    //为了降低最坏情况的出现概率，一般采取的做法是 随机选择轴点元素
    int randomIndex = begin+ random()%(end - begin);//[begin end)
    [self swapWithIndex1:begin index2:randomIndex];
    
    //备份pivot元素
    id pivot = self.array[begin];
    
    //因为是左闭右开所以end--;
    end--;

    //当begin = end时，结束
    while (begin<end) {
        
        
        while(begin<end){
            //末尾元素大于pivot，end-- 思考：可以将条件改为 <=0 吗？ 不可以
            if ([self compareWithValue1:pivot value2:self.array[end]] < 0) {
                end--;
                
            //末尾元素小于等于pivot,进行交换 begin++
            }else{
                //self.array[begin] = self.array[end];
                [self moveWithFromIndex:end toIndex:begin];
                begin++;
                
                //结束，进入轮换
                break;
            }
        }
        
        
        while(begin<end){
            //起始元素小于末尾元素，begin++ 思考：可以将条件改为 >=0 吗？ 不可以
            if ([self compareWithValue1:pivot value2:self.array[begin]] > 0) {
                begin++;
                
            //起始元素大于等于末尾元素，进行交换，end--
            }else{
                //self.array[end] = self.array[begin];
                [self moveWithFromIndex:begin toIndex:end];
                end--;
                
                //结束，进入轮换
                break;
            }
        }
    }
    
    //放置轴点元素
    self.array[begin] = pivot;
    
    //执行到此处begin == end 返回begin或end都可以。该位置就是pivot的索引
    return begin;
}
    
```






----------
>  行者常至，为者常成！


