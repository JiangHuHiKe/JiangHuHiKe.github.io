---
layout: post
title: "12、图（六）"
date: 2020-04-01
description: ""
tag: 数据结构与算法（二）
---






## 目录

* [Bellman-Ford](#content1)
* [Floyd](#content2)

 


<!-- ************************************************ -->
## <a id="content1"></a>Bellman-Ford

**一、算法原理**

Bellman-Ford 也属于单源最短路径算法，<span style="color:red;font-weight:bold">支持负权边，还能检测出是否有负权环</span>         
算法原理：<span style="font-weight:bold">对所有的边进行 V – 1 次松弛操作（ V 是节点数量），得到所有可能的最短路径</span>     
时间复杂度：O(EV) ，E 是边数量，V 是节点数量    

下图的最好情况是恰好从左到右的顺序对边进行松弛操作     
对所有边仅需进行 1 次松弛操作就能计算出A到达其他所有顶点的最短路径      

<img src="/images/DataStructurs2/graph50.png" alt="img">


最坏情况是恰好每次都从右到左的顺序对边进行松弛操作    
对所有边需进行 V – 1 次松弛操作才能计算出A到达其他所有顶点的最短路径     

<img src="/images/DataStructurs2/graph51.png" alt="img">

**二、实例**

<img src="/images/DataStructurs2/graph52.png" alt="img">

<img src="/images/DataStructurs2/graph53.png" alt="img">

<img src="/images/DataStructurs2/graph54.png" alt="img">


**三、代码实现**


```
/// begin到各顶点的最短路径(value:LCPathInfo)
/// @param begin 起始顶点
-(NSDictionary<id,LCPathInfo*>*)shortestPath:(id)begin{
    NSDictionary * dic = [self __bellmanFord:begin];
    return dic;
}

/// bellford算法返回value:LCPathInfo
/// @param begin 起始点
-(NSDictionary<id,LCPathInfo*>*)__bellmanFord:(id)begin{
    
    LCVertex* beginVertex = [self __verticsGetKey:begin];
    if (beginVertex == nil) return nil;


    //value:LCPathInfo  存放已经离开桌面的顶点（起始点到vertex的权重值，已经最终确定）
    NSMutableDictionary<id,LCPathInfo*> * selectedPaths = [NSMutableDictionary dictionary];
    LCPathInfo* beginPathInfo = [[LCPathInfo alloc] initWithWeight:self.weightManager.zero];
    [selectedPaths setObject:beginPathInfo forKey:begin];

    
    //对每个edge进行v-1次松弛，v为顶点数量
    int time = (int)self.edges.count-1;
    while (time--) {

        //NSSet的输出顺序是随机的，
        //但只要这个set对象不发生改变，其输出顺序永远是这个顺序
        for (LCEdge* edge in self.edges) {
            
            LCPathInfo* fromPathInfo = [selectedPaths objectForKey:edge.from.value];
            if (fromPathInfo == nil) {
                fromPathInfo = [[LCPathInfo alloc] init];
                [selectedPaths setObject:fromPathInfo forKey:edge.from.value];
            }
            
            LCPathInfo* toPathInfo = [selectedPaths objectForKey:edge.to.value];
            if (toPathInfo == nil) {
                toPathInfo = [[LCPathInfo alloc] init];
                [selectedPaths setObject:toPathInfo forKey:edge.to.value];
            }
            
            //对某一条边进行松弛操作
            [self __relaxEdge:edge fromPathInfo:fromPathInfo toPathInfo:toPathInfo];
            
        }
    }

    //去除起始点
    [selectedPaths removeObjectForKey:begin];

    return selectedPaths;
}




/// 对某一条边进行松弛操作,松弛成功返回true,失败返回false
/// @param edge 边
/// @param fromPathInfo 边的起始pathInfo对象
/// @param toPathInfo 边的终止pathInfo对象
-(BOOL)__relaxEdge:(LCEdge*)edge
      fromPathInfo:(LCPathInfo*)fromPathInfo
        toPathInfo:(LCPathInfo*)toPathInfo{
    
    id fromWeight = fromPathInfo.weight;
    if (fromWeight == nil) return false;
    id newWeight = [self.weightManager addE1:fromWeight e2:edge.weight];

    //松弛操作
    id toWeight   = toPathInfo.weight;
    if (toWeight == nil || [self.weightManager compareE1:newWeight e2:toWeight]<0) {
        toPathInfo.weight = newWeight;
        [toPathInfo.edgeInfos removeAllObjects];
        [toPathInfo.edgeInfos addObjectsFromArray:fromPathInfo.edgeInfos];
        [toPathInfo.edgeInfos addObject:edge.info];
    }
    
    return true;
}

```

<!-- ************************************************ -->
## <a id="content1"></a>Floyd



----------
>  行者常至，为者常成！


