---
layout: post
title: "1、排序"
date: 2020-03-10
description: ""
tag: 数据结构与算法（二）
---






## 目录

* [初识排序](#content1)
* [冒泡排序（Bubble Sort）](#content2)












<!-- ************************************************ -->
## <a id="content1"></a>初识排序

**一、什么叫排序？**  

排序前：3,1,6,9,2,5,8,4,7    
排序后：1,2,3,4,5,6,7,8,9（升序） 或者 9,8,7,6,5,4,3,2,1（降序）    

排序的应用无处不在

<img src="/images/DataStructurs2/sort1.png" alt="img">

**二、十大排序算法**

|名称| 时间复杂度(最好)| 时间复杂度(最坏)|时间复杂度((平均)| 空间复杂度 |In-place| 稳定性|
|冒泡排序（Bubble Sort）    | O(n)      | O(n2)| O(n2)| O(1) |✔| ✔|
|选择排序（Selection Sort） | O(n2)     | O(n2)| O(n2) |O(1)| ✔| ❌|
|插入排序（Insertion Sort） |O(n)       |O(n2)| O(n2)| O(1)| ✔| ✔|
|归并排序（Merge Sort）     |O(nlogn)   |O(nlogn)| O(nlogn)| O(n)| ❌| ✔|
|快速排序（Quick Sort）     |O(nlogn)   |O(n2)| O(nlogn)| O(logn)| ✔| ❌|
|希尔排序（Shell Sort）     |O(n)       |O(n4/3) ~ O(n2)| 取决于步长序列| O(1)| ✔| ❌|
|堆排序（Heap Sort）        |O(nlogn)   |O(nlogn)| O(nlogn) |O(1)| ✔ |❌|
|计数排序（Counting Sort）  |O(n + k)   |O(n + k)| O(n + k)| O(n + k)| ❌ |✔|
|基数排序（Radix Sort）   |O(d ∗ (n + k)) |O(d ∗ (n + k))| O(d ∗ (n + k))| O(n + k) |❌ |✔|
|桶排序（Bucket Sort）      |O(n + k) |O(n + k)| O(n + k)| O(n + m)| ❌| ✔|

以上表格是基于数组进行排序的一般性结论    
冒泡、选择、插入、归并、快速、希尔、堆排序，属于比较排序（Comparison Sorting）   


<!-- ************************************************ -->
## <a id="content2"></a>冒泡排序（Bubble Sort）

**一、Bubble Sort**

冒泡排序也叫做起泡排序   
执行流程（统一以升序为例子）
① 从头开始比较每一对相邻元素，如果第1个比第2个大，就交换它们的位置   
 执行完一轮后，最末尾那个元素就是最大的元素

② 忽略 ① 中曾经找到的最大元素，重复执行步骤 ①，直到全部元素有序

```
//时间复杂度:最好O(n^2)、最坏O(n^2)、平均O(n^2)
//空间复杂度O(1)
+(void)bubbleSort:(NSMutableArray*)array{
    for (int end = (int)array.count; end>1; end--) {
        for (int i = 1; i<end; i++) {
            if ([array[i-1] compare:array[i]] == NSOrderedDescending ) {
                id temp = array[i-1];
                array[i-1] = array[i];
                array[i] = temp;
            }
            
            NSLog(@"执行次数%d_%d",end,i);
        }
    }
}
```

**二、优化1**

如果序列已经完全有序，可以提前终止冒泡排序

<img src="/images/DataStructurs2/sort2.png" alt="img">

```
//时间复杂度:最好O(n)、最坏O(n^2)、平均O(n^2)
//空间复杂度O(1)
+(void)bubbleSort2:(NSMutableArray*)array{
    for (int end = (int)array.count; end>1; end--) {
        BOOL sorted = true;
        for (int i = 1; i<end; i++) {
            if ([array[i-1] compare:array[i]] == NSOrderedDescending ) {
                id temp = array[i-1];
                array[i-1] = array[i];
                array[i] = temp;
                
                //发生了交换
                sorted = false;
            }
            NSLog(@"执行次数%d_%d",end,i);
        }
        
        //没有发生交换，已经全部排序完成。
        if(sorted) break;
    }
}
```


**三、优化2**

如果序列尾部已经局部有序，可以记录最后1次交换的位置，减少比较次数   

<img src="/images/DataStructurs2/sort3.png" alt="img">

<center>最后1次交换的位置是 6</center>     


```
//时间复杂度:最好O(n)、最坏O(n^2)、平均O(n^2)
//空间复杂度O(1)
+(void)bubbleSort3:(NSMutableArray*)array{
    
    for (int end = (int)array.count; end>1; end--) {
        int index = 1;
        for (int i = 1; i<end; i++) {
            if ([array[i-1] compare:array[i]] == NSOrderedDescending ) {
                id temp = array[i-1];
                array[i-1] = array[i];
                array[i] = temp;
                
                //记录最后一次发生交换的index
                index = i;
            }
            NSLog(@"执行次数%d_%d",end,i);
        }
        //index及之后的数据已经排布好，不需要再次进行判断及交换
        end = index+1;
    }
}
```


**四、排序算法的稳定性（Stability）**

如果相等的2个元素，在排序前后的相对位置保持不变，那么这是稳定的排序算法    
排序前：5, 1, 3𝑎, 4, 7, 3𝑏     
稳定的排序： 1, 3𝑎, 3𝑏, 4, 5, 7     
不稳定的排序：1, 3𝑏, 3𝑎, 4, 5, 7     
<span style="color:red">对自定义对象进行排序时，稳定性会影响最终的排序效果</span>

冒泡排序属于稳定的排序算法

稍有不慎，稳定的排序算法也能被写成不稳定的排序算法，比如下面的冒泡排序代码是不稳定的

```
//时间复杂度:最好O(n^2)、最坏O(n^2)、平均O(n^2)
//空间复杂度O(1)
+(void)bubbleSort:(NSMutableArray*)array{
    for (int end = (int)array.count; end>1; end--) {
        for (int i = 1; i<end; i++) {
            if ([array[i-1] compare:array[i]] >=0 ) {
                id temp = array[i-1];
                array[i-1] = array[i];
                array[i] = temp;
            }
            
            NSLog(@"执行次数%d_%d",end,i);
        }
    }
}
```


**五、原地算法（In-place Algorithm）** 

何为原地算法？    
不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入   
空间复杂度为 𝑂(1) 的都可以认为是原地算法   

非原地算法，称为 Not-in-place 或者 Out-of-place    
冒泡排序属于 In-place    




----------
>  行者常至，为者常成！


