---
layout: post
title: "调试流程⭐️"
date: 2018-05-11
tag: Objective-C
---



## 目录
- [调试的核心角色](#content1)
- [调试流程](#content2)
- [常见调试命令（LLDB）](#content3)

## <a id="content1">调试的核心角色</a>

#### **一、在 iOS 调试中，主要涉及以下关键组件：**    

**Xcode**     
提供 IDE 和调试界面（断点、变量窗口、控制台）。      
负责编译、打包、符号文件管理、与设备通信。       

**LLDB(Low Level Debugger)**    
Apple 默认调试器（替代 GDB）。   
命令解析、符号解析（用 dSYM）、断点管理、格式化输出（变量、对象）、提供给 Xcode UI。           

**debugServer（运行在设备上）**     
iOS 设备上的代理。   
实际控制目标进程（启动/attach/暂停/继续）、读取/写入目标内存、读寄存器、设置/清除断点或硬件寄存器、当断点命中时向 LLDB 报告。       

**dSYM 文件**   
保存 App 的 DWARF 调试信息（符号表、源码映射）。   
用于把机器地址 ↔ 源文件/函数/变量对应起来。   

**DeviceSupport**     
存放 iOS 系统的符号（系统 Frameworks、dyld、libobjc 等）。    
存放 DeveloperDiskImage.dmg，挂载到设备用于调试。     


#### **二、调试中的配合关系**     

```text
App 地址 -----> dSYM -----> 源代码/行号/变量
系统库地址 ---> DeviceSupport/Symbols ----> 系统函数名
LLDB 命令 -----> debugserver -----> 设备执行/返回数据
```

#### **三、通信**    

LLDB 与 debugserver 用“远程调试协议”在一条通道上通信（通过 USB 隧道或网络端口）。Xcode 实际上是用 LLDB 做后端，UI 把命令发给 LLDB。

简化流程：Xcode UI → LLDB (client) → (remote protocol) → debugserver (device) → target process。


## <a id="content2">调试流程</a>


#### **一、流程**    

```text
[1] Xcode 编译 App (Debug)
      │
      ├─► 生成 App 可执行文件 (Mach-O)
      │
      └─► 生成 dSYM (存放源码符号信息)
                  │
                  ▼
[2] Xcode 连接设备
      │
      ├─► 查找 DeviceSupport/<iOS版本>/
      │       │
      │       ├─ DeveloperDiskImage.dmg → 挂载到设备 → 启动 debugserver(监听调试端口、负责执行、暂停、内存访问)
      │       │
      │       └─ Symbols → 提供系统库符号 (UIKit, libobjc 等)
      │
      └─► 如果找不到完全匹配的版本 (如 16.5)，
              尝试使用最近的版本 (如 16.4)
                  │
                  ▼
[3] LLDB attach 到 debugserver（通过 USB 连接，建立调试通道）
      │
      ├─► 使用 dSYM 映射 App 自己的函数/变量/行号
      │
      └─► 使用 DeviceSupport/Symbols 映射系统框架的符号
                  │
                  ▼
[4] 用户打断点 / 查看调用栈
      │
      ├─► Xcode App 内代码 → LLDB 使用 dSYM 精准解析 → debugserver
      │
      ├─► 系统框架代码 → LLDB 使用 DeviceSupport 符号 (缺失时显示地址) → debugserver
      │
      ├─► debugserver 捕获断点
      │
      └─► debugserver → 通知 LLDB → Xcode 界面刷新


```


#### **二、Xcode 的断点是如何传递给 debugserver 的，debugserver 是如何命中的？**    

```swift
1. 用户在 Xcode 设置断点（UI / Breakpoint Navigator）
    ↓
2. Xcode 将断点下发给 LLDB（LLDB 客户端在本地接受）
    ↓
3. LLDB 解析断点（符号->地址）：使用 image list/dSYM 把 源文件/函数 名 -> 内存地址 映射
    ↓
4. LLDB 向 debugserver 发起“设置断点”请求（告知地址、类型）
    ↓
5. debugserver 在目标进程上实现断点（软件断点或硬件断点 / watchpoint）
    ↓
6. 目标进程运行到断点地址 → CPU 触发异常 → debugserver 捕获异常并向 LLDB 报告 → LLDB 通知 Xcode UI

```

## <a id="content3">常见调试命令（LLDB）</a>


| 命令                             | 作用                              |
| ------------------------------ | ------------------------------- |
| `bt`                           | 打印调用栈 (backtrace)               |
| `frame variable`               | 查看当前函数作用域的变量                    |
| `po object`                    | 打印对象（调用 `NSObject description`） |
| `image list`                   | 查看已加载的二进制和符号                    |
| `image lookup -n functionName` | 查找函数符号                          |
| `register read`                | 查看寄存器                           |
| `expr (type) var`              | 强制类型转换并查看变量                     |



----------
>  行者常至，为者常成！


