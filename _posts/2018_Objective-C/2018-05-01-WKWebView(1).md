---
layout: post
title: "WKWebView(1)"
date: 2018-05-01
tag: Objective-C
--- 

- [WKWebView进阶使用总结 - JS交互（一）](https://juejin.cn/post/7062920887065903117)
- [超详细 WKWebView 开发和使用经验](https://www.51cto.com/article/676860.html)    
- [iOS学习笔记 — WKWebView的使用](https://blog.csdn.net/Alexander_Wei/article/details/78360591)   



## 目录
* [介绍](#content1)
* [调试](#content2)
* [常规使用](#content3)
* [native 和 js 通讯](#content4)



<!-- ************************************************ -->
## <a id="content1">介绍</a>

#### **一、什么是WKWebView**   

在某种程度上，可以将一个 WebView 实例比喻为一个简化的浏览器。   
WebView 是一种用于在应用程序中显示网页内容的组件，它允许应用程序集成网页浏览的功能，但与完整的浏览器相比，它通常是一个轻量级的解决方案，仅提供了基本的浏览功能。

一个 WebView 实例允许你在应用程序中显示网页、加载并呈现 HTML 内容，执行 JavaScript 代码，并与网页进行交互。    
你可以通过 WebView 来显示网页内容，处理用户输入，以及在应用中嵌入网页体验。     
    
然而，WebView 并不具备完整的浏览器功能，例如地址栏、书签管理、多标签浏览、插件支持等。    
WebView 是为了在应用程序中嵌入和显示 Web 内容而设计的，而不是为了提供完整的浏览器体验。     

所以，理解为一个简化的浏览器是有道理的，但要注意它通常不包含完整的浏览器功能集。     
WebView 更多地被用于应用程序中嵌入和展示特定的 Web 内容，而不是作为一个独立的全功能浏览器。


#### **二、WKWebViewConfiguration**

WKWebViewConfiguration 是用于配置 WKWebView 实例的类，允许你在创建 WKWebView 对象时设置一些选项和属性，以满足特定的需求。     
通过配置对象，你可以影响 WebView 的行为、添加脚本、设置用户内容控制规则等。     

以下是 WKWebViewConfiguration 的一些主要属性和用法：

**userContentController 属性：**      
这个属性允许你配置 WKUserContentController 对象，用于处理与 JavaScript 通信，注入自定义脚本等     

```objc
WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];
// 添加脚本消息处理器<WKScriptMessageHandler>
[configuration.userContentController addScriptMessageHandler:self name:@"myHandler"];
```

**applicationNameForUserAgent 属性：**    
该属性允许你设置 WebView 的 User-Agent 中包含的应用程序名称。     
```objc
WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];
configuration.applicationNameForUserAgent = @"MyApp";
```

#### **三、WKWebsiteDataStore介绍**   

WKWebsiteDataStore 是 WebKit 框架中的一个类，用于管理与网站相关的数据。    
这个类的主要目的是提供一种方式来管理缓存、Cookies、本地存储等网站数据，以及处理网站数据的相关配置。    

以下是 WKWebsiteDataStore 的一些主要功能和用途：

**数据存储隔离：** WKWebsiteDataStore 允许你为每个 WKWebView 实例创建一个独立的数据存储，从而实现不同 WebView 之间的数据隔离。这对于实现多个 WebView 之间的独立状态或隔离用户数据非常有用。

**缓存管理：** 通过 WKWebsiteDataStore，你可以清除和管理 WebView 缓存。这包括清除缓存中的资源文件、页面数据等。

**Cookies 管理：** 可以通过 WKWebsiteDataStore 来管理 Cookies，包括添加、删除和查询 Cookies。这对于处理用户身份验证和跟踪用户会话非常有用。

**本地存储管理：** WKWebsiteDataStore 允许你管理 WebView 的本地存储，包括本地数据库、localStorage 等。

**HTTP 缓存策略：** 提供了一些配置选项，用于设置 WebView 的 HTTP 缓存策略。

下面是一个简单的示例，展示了如何创建一个自定义的 WKWebsiteDataStore：

```objc
-(void)storeUsage {
    // 创建一个默认配置的 WKWebViewConfiguration
    WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];

    // 创建一个自定义的 WKWebsiteDataStore，Non-Persistent Data Store（非持久数据存储，程序退出数据清除）
    WKWebsiteDataStore *dataStore = [WKWebsiteDataStore nonPersistentDataStore];
    
    // 获取默认store,持久存储，这种类型的数据存储会将数据永久保存在磁盘上，即使应用程序退出或设备重启，数据依然存在
    // 通常情况下，如果你需要在应用程序的多个 WKWebView 实例之间共享某些数据，可以使用持久数据存储。
    // 如果你只需要一个短暂的、与应用程序生命周期相对独立的数据存储，可以使用非持久数据存储。
    // 选择使用哪种数据存储取决于你的应用程序的需求和设计。
    // WKWebsiteDataStore *persistentDataStore = [WKWebsiteDataStore defaultDataStore];


    // 将自定义的 WKWebsiteDataStore 设置给 WKWebViewConfiguration
    configuration.websiteDataStore = dataStore;

    // 使用带有配置的 WKWebView 实例
    WKWebView *wkWebView = [[WKWebView alloc] initWithFrame:CGRectZero configuration:configuration];
}
```

清除缓存     
```objc
- (void)__cleanWKWebViewCache{
    NSSet *websiteDataTypes = [NSSet setWithArray:@[WKWebsiteDataTypeDiskCache]];
    // NSSet *websiteDataTypes = [WKWebsiteDataStore allWebsiteDataTypes];
    
    NSDate *dateFrom = [NSDate dateWithTimeIntervalSince1970:0];
    
    [[WKWebsiteDataStore defaultDataStore] removeDataOfTypes:websiteDataTypes
                                               modifiedSince:dateFrom
                                           completionHandler:^{
    }];
}
```


<!-- ************************************************ -->
## <a id="content2">调试</a>

- [参考文章：iOS 16.4 之后真机与模拟器无法使用Safari调试H5页面问题](https://blog.csdn.net/weixin_36162680/article/details/134273457)

解决方法

```objc
// 在WKWebView中设置以下代码解决
if (@available(iOS 16.4, *)) {
    [_webView setInspectable:YES];
}
```


<!-- ************************************************ -->
## <a id="content3">常规使用</a>

#### **一、初始化**  
```objc
- (void)initWKWebView{
    // 清除webview的缓存
    [self __cleanWKWebViewCache];
    
    
    // 创建实例对象
    CGRect frame = CGRectMake(20, 200, self.view.frame.size.width - 40, self.view.frame.size.height - 300);
    WKWebViewConfiguration *config = [self __getWKWebViewConfiguration];
    self.wkWebView = [[WKWebView alloc] initWithFrame:frame configuration:config];
    // 两个关键协议
    self.wkWebView.navigationDelegate = self;
    self.wkWebView.UIDelegate = self;
    //开启safari调试
    if (@available(iOS 16.4, *)) { [self.wkWebView setInspectable:YES];}
   
    // 常规设置
    self.wkWebView.backgroundColor = [UIColor grayColor];
    self.wkWebView.scrollView.backgroundColor = [UIColor clearColor];
    //是否允许左右划手势导航，默认不允许
    self.wkWebView.allowsBackForwardNavigationGestures = YES;
    [self.view addSubview:self.wkWebView];

    // 加载进度条设置
    self.progresslayer = [self __observeProgressForWkWebView:self.wkWebView];

    // 加载url
    if (self.url) {
        if ([self.url hasPrefix:@"http"]) { //加载网络文件
            NSURLRequest *req = [NSURLRequest requestWithURL:[NSURL URLWithString:self.url]];
            [self.wkWebView loadRequest:req];
        } else {//加载本地文件
            NSURL * fileUrl = [NSURL fileURLWithPath:self.url];
            /**
             包含您授予系统读取权限的web内容的文件或目录的URL。
             此URL必须是基于文件的URL，并且不能为空。
             为了防止WebKit读取任何其他内容，请指定与URL参数相同的值。
             要读取与内容文件相关的其他文件，请指定一个目录。
             */
            [self.wkWebView loadFileURL:fileUrl allowingReadAccessToURL:fileUrl];
        }
    }
}
```

#### **二、监听事件**    

**1、监听事件汇总**    
```objc
- (void)addObserverForKeyPath {
    
    /**
     title: 网页的标题，一般为 html 中的 中的内容
     URL: 网页的URL地址，为最终加载的地址
     loading: 网页是否处于加载中，YES 加载中、 NO 加载完成
     estimatedProgress: 网页加载进度
     hasOnlySecureContent: 网页上的所有资源是否已通过 https 加载
     serverTrust: 加载 HTTPS 请求服务端所信任的证书
     
     */
    // NSKeyValueObservingOptionNew 更改后的值
    // NSKeyValueObservingOptionOld 更改前的值
    // NSKeyValueObservingOptionInitial 观察初始化的值（在注册观察服务时会调用一次触发方法）
    // NSKeyValueObservingOptionPrior 分别在值修改前后触发方法（即一次修改有两次触发）
    [self.webView addObserver:self forKeyPath:@"title" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];
    [self.webView addObserver:self forKeyPath:@"URL" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];
    [self.webView addObserver:self forKeyPath:@"loading" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];
    [self.webView addObserver:self forKeyPath:@"estimatedProgress" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];
    [self.webView addObserver:self forKeyPath:@"hasOnlySecureContent" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];
    [self.webView addObserver:self forKeyPath:@"serverTrust" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];
}
```

**2、通过监听展示加载进度条**   

```objc
self.progresslayer = [self __observeProgressForWkWebView:self.wkWebView];

-(CALayer*)__observeProgressForWkWebView:(WKWebView*)weView{
    [weView addObserver:self forKeyPath:@"estimatedProgress" options:NSKeyValueObservingOptionNew context:nil];
    UIView *progress = [[UIView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, 3)];
    progress.backgroundColor = [UIColor clearColor];
    [weView addSubview:progress];
    
    CALayer *layer = [CALayer layer];
    layer.frame = CGRectMake(0, 0, 0, 3);
    UIColor *tintColor = [UIColor blueColor];
    layer.backgroundColor = tintColor.CGColor;
    [progress.layer addSublayer:layer];
    return layer;
}


- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> *)change context:(void *)context{
    if ([keyPath isEqualToString:@"estimatedProgress"]) {
        self.progresslayer.opacity = 1;
        //不要让进度条倒着走...有时候goback会出现这种情况
        if ([change[@"new"] floatValue] < [change[@"old"] floatValue]) { return;}
        
        self.progresslayer.frame = CGRectMake(0, 0, self.view.bounds.size.width * [change[@"new"] floatValue], 3);
        if ([change[@"new"] floatValue] == 1) {
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(.4 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                self.progresslayer.opacity = 0;
            });
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                self.progresslayer.frame = CGRectMake(0, 0, 0, 3);
            });
        }
    }else{
        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];
    }
}

-(void)dealloc{
    [self.wkWebView removeObserver:self forKeyPath:@"estimatedProgress"];
    [[NSNotificationCenter defaultCenter] removeObserver:self];
}
```

#### **三、两个协议**  

**1、WKNavigationDelegate**       
主要处理一些跳转、加载处理操作    

```objc
// 调用顺序1：在发送请求之前，决定是否跳转:用户点击网页上的链接，需要打开新页面时，将先调用这个方法。
- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler{
    
    NSLog(@"----在发送请求之前，决定是否跳转：%@",webView.URL);
    
    NSURL* url = webView.URL;
    NSLog(@"url=%@",url);
    if ([url.scheme isEqualToString:@"event"]) {
        NSLog(@"jsCallNativeTwo");
    }else{
        NSLog(@"打开页面");
    }
    
    
    //设置请求头：判断请求头是否存在Test字段，如果否，则表示该请求尚未设置请求头
    NSMutableURLRequest *mutableRequest = [navigationAction.request mutableCopy];
    NSDictionary *headFields = mutableRequest.allHTTPHeaderFields;
    if(![headFields objectForKey:@"Test"]){
        NSLog(@"[lilog]:不包含");
        decisionHandler(WKNavigationActionPolicyCancel);
        //如果Test不存在会创建，存在会更新Test对应的value Test:"test"
        [mutableRequest setValue:@"test" forHTTPHeaderField:@"Test"];
        //如果Test不存在会创建，存在会追加Test对应的value Test:"test,add"
        [mutableRequest addValue:@"add" forHTTPHeaderField:@"Test"];
        [webView loadRequest:mutableRequest];
    }else{
        NSLog(@"[lilog]:包含");
        decisionHandler(WKNavigationActionPolicyAllow);
    }
    
    //允许跳转
    //decisionHandler(WKNavigationActionPolicyAllow);
    
    //不允许跳转
    //decisionHandler(WKNavigationActionPolicyCancel);
}


// 调用顺序2：页面开始加载时调用
- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(WKNavigation *)navigation {
    NSLog(@"----页面开始加载:%@",webView.URL);
}


// 调用顺序3：在收到响应后，决定是否跳转
-(void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler {
    NSLog(@"----在收到响应后，决定是否跳转:%@",webView.URL);
    //允许跳转
    decisionHandler(WKNavigationResponsePolicyAllow);
    //不允许跳转
    //decisionHandler(WKNavigationResponsePolicyCancel);
}


// 调用顺序4：当内容开始返回时调用
- (void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation {
    NSLog(@"----页面返回内容:%@",webView.URL);
    // 检查当前加载的URL是否与原始请求的URL不同，即发生了重定向
    if (![webView.URL.absoluteString isEqualToString:@"http://www.baidu.com"]) {
        NSLog(@"----重定向到: %@", webView.URL);
        // 在这里可以执行相应的操作
    }
}


// 调用顺序5：页面加载完成时调用
- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation {
    // 加载完成后的处理，可以用于更新界面或执行其他操作
    NSLog(@"----页面加载完成:%@",webView.URL);
}

// 调用顺序5：页面加载失败时调用
- (void)webView:(WKWebView *)webView didFailNavigation:(WKNavigation *)navigation withError:(NSError *)error {
    NSLog(@"----页面加载失败:%@",webView.URL);
}


//方法是在接收到服务器重定向时调用的
- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(WKNavigation *)navigation {
    NSLog(@"----接收到服务器跳转请求之后调用:%@",webView.URL);
    /**
     它可能并不会被所有的重定向触发。在某些情况下，WKWebView 会自动处理重定向，而不会通知到应用程序的 WKNavigationDelegate。
     
     在你的例子中，百度的网址 http://www.baidu.com 确实会被重定向到 https://www.baidu.com，
     但是这个重定向可能在 WKWebView 内部处理，而不会触发 didReceiveServerRedirectForProvisionalNavigation 方法。
     
     如果你需要处理这种重定向，可以考虑使用 WKNavigationDelegate 的其他方法，比如 didCommitNavigation 或 didFinishNavigation。
     在这些方法中，你可以检查实际加载的 URL，以便确定是否发生了重定向。
     */
}


// 处理身份验证挑战
- (void)webView:(WKWebView *)webView didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler {
    NSLog(@"----身份认证:%@",webView.URL);
    BOOL isAllow = YES;// 检查身份验证条件
    if (isAllow) {
        NSURLCredential *credential = [NSURLCredential credentialWithUser:@"username" password:@"password" persistence:NSURLCredentialPersistenceForSession];
        completionHandler(NSURLSessionAuthChallengeUseCredential, credential);
    } else {
        completionHandler(NSURLSessionAuthChallengeCancelAuthenticationChallenge, nil);
    }
}
```


<!-- ************************************************ -->
## <a id="content4">native 和 js 通讯</a>

#### **一、native调用js方法**   



##### **二、js调用native方法**    

**1、js代码**   
```js
//实现自定义的OCLog方法
function ocLog(text){
    //传递的信息
    try {
        window.webkit.messageHandlers.ocLog.postMessage(text)
    } catch(error) {
        console.log(error)
    }
}

//原生端注册getMessage
function jsCallNative(param){
    //传递的信息
    var jsonStr = '{"id":"666", "message":"我是传递的数据"}';
    try {
        window.webkit.messageHandlers.getMessage.postMessage(jsonStr)
    } catch(error) {
        console.log(error)
    }
}
```


**2、native代码**     
```objc
WKWebViewConfiguration *config = [self __getWKWebViewConfiguration];
self.wkWebView = [[WKWebView alloc] initWithFrame:frame configuration:config];

//注册js事件
-(WKWebViewConfiguration*)__getWKWebViewConfiguration{
    WKWebViewConfiguration * config = [[WKWebViewConfiguration alloc] init];
    [config.userContentController addScriptMessageHandler:(id<WKScriptMessageHandler>)self name:@"getMessage"];
    [config.userContentController addScriptMessageHandler:(id<WKScriptMessageHandler>)self name:@"ocLog"];
    
    // js注入，注入一个alert方法，页面加载完毕弹出一个对话框。
    // WKUserScriptInjectionTimeAtDocumentStart：页面刚渲染前执行。
    // WKUserScriptInjectionTimeAtDocumentEND：页面渲染后执行。
    // forMainFrameOnly:NO(全局窗口)，yes（只限主窗口）
    NSString *javaScriptSource = @"alert(\"WKUserScript注入js\");";
    WKUserScript *userScript = [[WKUserScript alloc] initWithSource:javaScriptSource
                                                    injectionTime:WKUserScriptInjectionTimeAtDocumentEnd
                                                forMainFrameOnly:YES];
    [config.userContentController addUserScript:userScript];
    return config;
}


#pragma mark WKScriptMessageHandler
- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message{
    //2023-12-18 15:54:47.815436+0800 XYApp[92178:35576261] xy:message.name = ocLog, message.body = ocLogTest, message.framInfo = <WKFrameInfo: 0x7fac8c910380; webView = 0x7fac8d074e00; isMainFrame = YES; request = <NSMutableURLRequest: 0x6000002a8680> { URL: file:///Users/lixiaoyi/Library/Developer/CoreSimulator/Devices/9DA297BF-FD4C-4A1B-A483-B35D97BF1F1F/data/Containers/Bundle/Application/3F199C2E-D536-47D7-B402-C309FE2EAA18/XYApp.app/Frameworks/XYTestModule.framework/XYTestModule.bundle/test.html }>
    NSLog(@"xy:message.name = %@, message.body = %@, message.framInfo = %@", message.name, message.body, message.frameInfo);
    
    
    if ([message.name isEqualToString:@"ocLog"]) {
        NSLog(@"xy:ocLog");
    }else if([message.name isEqualToString:@"getMessage"]){
        NSLog(@"xy:getMessage");
    }

    NSString *methods = [NSString stringWithFormat:@"%@:", message.name];
    SEL selector = NSSelectorFromString(methods);
    if ([self respondsToSelector:selector]) {
        [self performSelector:selector onThread:[NSThread mainThread] withObject:message.body waitUntilDone:NO];
    } else {
        NSLog(@"xy:方法未实现：%@", methods);
    }
}
```

**其它调用方式**   

```js
//js调用原生事件 方法二：
//通过隐藏iframe的方式，加载一个url，Native的WebView拦截url，并执行相应方法
function jsCallNativeTwo(){
    var url = "event://jsCallNativeTwo";
    var iFrame;
    iFrame = document.createElement("iframe");
    iFrame.setAttribute("src", url);
    iFrame.setAttribute("style", "display:none;");
    iFrame.setAttribute("height", "0px");
    iFrame.setAttribute("width", "0px");
    iFrame.setAttribute("frameborder", "0");
    document.body.appendChild(iFrame);
    // 发起请求后这个 iFrame 就没用了，所以把它从 dom 上移除掉
    iFrame.parentNode.removeChild(iFrame);
    iFrame = null;
}
```



----------
>  行者常至，为者常成！



