---
layout: post
title: "WKWebView(1)"
date: 2018-05-01
tag: Objective-C
--- 

- [超详细 WKWebView 开发和使用经验](https://www.51cto.com/article/676860.html)    
- [iOS学习笔记 — WKWebView的使用](https://blog.csdn.net/Alexander_Wei/article/details/78360591)   



## 目录
* [介绍](#content1)
* [调试](#content2)
* [使用](#content3)



<!-- ************************************************ -->
## <a id="content1">介绍</a>

#### **一、什么是WKWebView**   

在某种程度上，可以将一个 WebView 实例比喻为一个简化的浏览器。   
WebView 是一种用于在应用程序中显示网页内容的组件，它允许应用程序集成网页浏览的功能，但与完整的浏览器相比，它通常是一个轻量级的解决方案，仅提供了基本的浏览功能。

一个 WebView 实例允许你在应用程序中显示网页、加载并呈现 HTML 内容，执行 JavaScript 代码，并与网页进行交互。    
你可以通过 WebView 来显示网页内容，处理用户输入，以及在应用中嵌入网页体验。     
    
然而，WebView 并不具备完整的浏览器功能，例如地址栏、书签管理、多标签浏览、插件支持等。    
WebView 是为了在应用程序中嵌入和显示 Web 内容而设计的，而不是为了提供完整的浏览器体验。     

所以，理解为一个简化的浏览器是有道理的，但要注意它通常不包含完整的浏览器功能集。     
WebView 更多地被用于应用程序中嵌入和展示特定的 Web 内容，而不是作为一个独立的全功能浏览器。


#### **二、WKWebViewConfiguration**

WKWebViewConfiguration 是用于配置 WKWebView 实例的类，允许你在创建 WKWebView 对象时设置一些选项和属性，以满足特定的需求。     
通过配置对象，你可以影响 WebView 的行为、添加脚本、设置用户内容控制规则等。     

以下是 WKWebViewConfiguration 的一些主要属性和用法：

**userContentController 属性：**      
这个属性允许你配置 WKUserContentController 对象，用于处理与 JavaScript 通信，注入自定义脚本等     

```objc
WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];
// 添加脚本消息处理器<WKScriptMessageHandler>
[configuration.userContentController addScriptMessageHandler:self name:@"myHandler"];
```

**applicationNameForUserAgent 属性：**    
该属性允许你设置 WebView 的 User-Agent 中包含的应用程序名称。     
```objc
WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];
configuration.applicationNameForUserAgent = @"MyApp";
```

#### **三、WKWebsiteDataStore介绍**   

WKWebsiteDataStore 是 WebKit 框架中的一个类，用于管理与网站相关的数据。    
这个类的主要目的是提供一种方式来管理缓存、Cookies、本地存储等网站数据，以及处理网站数据的相关配置。    

以下是 WKWebsiteDataStore 的一些主要功能和用途：

**数据存储隔离：** WKWebsiteDataStore 允许你为每个 WKWebView 实例创建一个独立的数据存储，从而实现不同 WebView 之间的数据隔离。这对于实现多个 WebView 之间的独立状态或隔离用户数据非常有用。

**缓存管理：** 通过 WKWebsiteDataStore，你可以清除和管理 WebView 缓存。这包括清除缓存中的资源文件、页面数据等。

**Cookies 管理：** 可以通过 WKWebsiteDataStore 来管理 Cookies，包括添加、删除和查询 Cookies。这对于处理用户身份验证和跟踪用户会话非常有用。

**本地存储管理：** WKWebsiteDataStore 允许你管理 WebView 的本地存储，包括本地数据库、localStorage 等。

**HTTP 缓存策略：** 提供了一些配置选项，用于设置 WebView 的 HTTP 缓存策略。

下面是一个简单的示例，展示了如何创建一个自定义的 WKWebsiteDataStore：

```objc
-(void)storeUsage {
    // 创建一个默认配置的 WKWebViewConfiguration
    WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];

    // 创建一个自定义的 WKWebsiteDataStore，Non-Persistent Data Store（非持久数据存储，程序退出数据清除）
    WKWebsiteDataStore *dataStore = [WKWebsiteDataStore nonPersistentDataStore];
    
    // 获取默认store,持久存储，这种类型的数据存储会将数据永久保存在磁盘上，即使应用程序退出或设备重启，数据依然存在
    // 通常情况下，如果你需要在应用程序的多个 WKWebView 实例之间共享某些数据，可以使用持久数据存储。
    // 如果你只需要一个短暂的、与应用程序生命周期相对独立的数据存储，可以使用非持久数据存储。
    // 选择使用哪种数据存储取决于你的应用程序的需求和设计。
    // WKWebsiteDataStore *persistentDataStore = [WKWebsiteDataStore defaultDataStore];


    // 将自定义的 WKWebsiteDataStore 设置给 WKWebViewConfiguration
    configuration.websiteDataStore = dataStore;

    // 使用带有配置的 WKWebView 实例
    WKWebView *wkWebView = [[WKWebView alloc] initWithFrame:CGRectZero configuration:configuration];
}
```

清除缓存     
```objc
- (void)__cleanWKWebViewCache{
    NSSet *websiteDataTypes = [NSSet setWithArray:@[WKWebsiteDataTypeDiskCache]];
//    NSSet *websiteDataTypes = [WKWebsiteDataStore allWebsiteDataTypes];
    
    NSDate *dateFrom = [NSDate dateWithTimeIntervalSince1970:0];
    
    [[WKWebsiteDataStore defaultDataStore] removeDataOfTypes:websiteDataTypes
                                               modifiedSince:dateFrom
                                           completionHandler:^{
    }];
}
```


<!-- ************************************************ -->
## <a id="content2">调试</a>

- [参考文章：iOS 16.4 之后真机与模拟器无法使用Safari调试H5页面问题](https://blog.csdn.net/weixin_36162680/article/details/134273457)

解决方法

```objc
// 在WKWebView中设置以下代码解决
if (@available(iOS 16.4, *)) {
    [_webView setInspectable:YES];
}
```


<!-- ************************************************ -->
## <a id="content3">使用</a>

#### **一、初始化**  
```objc
- (void)initWKWebView{
    [self __cleanWKWebViewCache];
    CGRect frame = CGRectMake(20, 200, self.view.frame.size.width - 40, self.view.frame.size.height - 300);
    WKWebViewConfiguration *config = [self __getWKWebViewConfiguration];
    self.wkWebView = [[WKWebView alloc] initWithFrame:frame configuration:config];
    
    //开启safari调试
    if (@available(iOS 16.4, *)) {
        [self.wkWebView setInspectable:YES];
    }

    self.wkWebView.navigationDelegate = self;
    self.wkWebView.UIDelegate = self;
    self.wkWebView.backgroundColor = [UIColor grayColor];
    self.wkWebView.scrollView.backgroundColor = [UIColor clearColor];
    //是否允许左右划手势导航，默认不允许
    self.wkWebView.allowsBackForwardNavigationGestures = YES;
    [self.view addSubview:self.wkWebView];

    if (self.url) {
        if ([self.url hasPrefix:@"http"]) { //加载网络文件
           
            NSURLRequest *req = [NSURLRequest requestWithURL:[NSURL URLWithString:self.url]];
            [self.wkWebView loadRequest:req];
            
        } else {//加载本地文件
            
            NSURL * fileUrl = [NSURL fileURLWithPath:self.url];
            
            /**
             包含您授予系统读取权限的web内容的文件或目录的URL。
             此URL必须是基于文件的URL，并且不能为空。
             为了防止WebKit读取任何其他内容，请指定与URL参数相同的值。
             要读取与内容文件相关的其他文件，请指定一个目录。
             */
            [self.wkWebView loadFileURL:fileUrl allowingReadAccessToURL:fileUrl];
        }
    }
}


- (void)__cleanWKWebViewCache{
    NSSet *websiteDataTypes = [NSSet setWithArray:@[WKWebsiteDataTypeDiskCache]];
    //NSSet *websiteDataTypes = [WKWebsiteDataStore allWebsiteDataTypes];
    NSDate *dateFrom = [NSDate dateWithTimeIntervalSince1970:0];
    [[WKWebsiteDataStore defaultDataStore] removeDataOfTypes:websiteDataTypes
                                               modifiedSince:dateFrom
                                           completionHandler:^{
    }];
}

//注册js事件
-(WKWebViewConfiguration*)__getWKWebViewConfiguration{
    WKWebViewConfiguration * config = [[WKWebViewConfiguration alloc] init];
    [config.userContentController addScriptMessageHandler:(id<WKScriptMessageHandler>)[XYProxy proxyWithTarget:self] name:@"getMessage"];
    [config.userContentController addScriptMessageHandler:(id<WKScriptMessageHandler>)[XYProxy proxyWithTarget:self] name:@"ocLog"];
    
    // js注入，注入一个alert方法，页面加载完毕弹出一个对话框。
    // forMainFrameOnly:NO(全局窗口)，yes（只限主窗口）
     NSString *javaScriptSource = @"alert(\"WKUserScript注入js\");";
     WKUserScript *userScript = [[WKUserScript alloc] initWithSource:javaScriptSource
                                                       injectionTime:WKUserScriptInjectionTimeAtDocumentEnd
                                                    forMainFrameOnly:YES];
     [config.userContentController addUserScript:userScript];
    return config;
}
```











----------
>  行者常至，为者常成！



