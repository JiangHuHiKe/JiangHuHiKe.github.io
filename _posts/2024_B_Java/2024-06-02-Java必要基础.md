---
layout: post
title: "Java 必要基础"
date: 2024-06-02
tag: Java
---




## 目录
- [Java 的骨架](#content1)   
- [注解(重点)](#content2)   



## <a id="content1">Java 的骨架</a>

#### **一、类 和 构造方法**   

```java
public class User {
    private String name;
    private int age;

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }
}
```

public / private：访问控制    

构造函数 = 初始化对象    

Getter / Setter 是常态（和 Swift 不一样）   

#### **二、接口（非常重要）**    

```java
public interface UserService {
    User findById(Long id);
}
```

```java
public class UserServiceImpl implements UserService {
    @Override
    public User findById(Long id) {
        return new User("Tom", 18);
    }
}
```
Spring 90% 都围绕接口 + 实现



#### **三、泛型 & 集合**    

```java
List<User> users = new ArrayList<>();
Map<Long, User> userMap = new HashMap<>();
```

```java
public class Result<T> {
    private int code;
    private T data;
}
```


#### **四、Optional & Stream（认知即可）**    

**Optional**    
```java
// 如果findUser()返回非null的User对象，则创建包含该对象的Optional。
// 如果返回null，则创建一个空的Optional对象（Optional.empty()）。
Optional<User> user = Optional.ofNullable(findUser());


// ifPresent()：是Optional的方法
// 如果Optional中有值（非空），则执行传入的Lambda表达式。
// 如果为空，则什么都不做。
user.ifPresent(
    u -> System.out.println(u.getName())
);

// 传统写法对比
User user = findUser();
if (user != null) {
    System.out.println(user.getName());
}
```

使用Optional的优点是：   
明确表达“值可能不存在”的语义。   
避免潜在的NullPointerException。    
鼓励函数式编程风格。

**Stream（知道这是“链式操作”）**    

```java
users.stream()
     .filter(u -> u.getAge() > 18)
     .map(User::getName)
     .toList();
```

Stream 并不是一种数据结构，它不存储数据，而是从数据源（如集合、数组）获取数据并通过流水线（Pipeline）进行计算    
有点类似swift中的Combine


## <a id="content2">注解(重点)</a>


Spring 的“魔法”全靠注解。    
注解本质是： “告诉 Spring：这个类是干什么的”   

| 注解              | 作用      |
| --------------- | ------- |
| @Component      | 普通组件    |
| @Service        | 业务层     |
| @Repository     | 数据层     |
| @Controller     | Web 控制层 |
| @RestController | 返回 JSON |
| @Autowired      | 注入依赖    |


```java
@RestController
public class UserController {

    @Autowired
    private UserService userService;
}
```

要理解的是：   
你没有 new UserService    
Spring 帮你创建并管理     
Controller 只“用”，不“管生死”



----------
>  行者常至，为者常成！


