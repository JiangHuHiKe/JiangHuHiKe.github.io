---
layout: post
title: "结构体"
date: 2018-06-01
description: "结构体"
tag: C语言
---


<h6>
  版权声明：本文为博主原创文章，未经博主允许不得转载。
  <a target="_blank" href="https://jianghuhike.github.io/1861.html">
  原文地址：https://jianghuhike.github.io/1861.html 
  </a>
</h6>

- [参考文章：结构体大小与内存对齐问题](https://www.cnblogs.com/johnleo/p/struct_size.html)




## 目录

* [结构体介绍](#content1)
* [结构体大小及内存对齐](#content2)




<!-- ************************************************ -->
## <a id="content1"></a>结构体介绍


<!-- ************************************************ -->
## <a id="content2"></a>结构体大小及内存对齐

结构体中的成员可以是不同的数据类型，成员按照定义时的顺序依次存储在连续的内存空间。    
但需要考虑到系统在存储结构体变量时的地址对齐问题。   

什么是对齐？    
现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。    

为什么要对齐？
为了提高数据的存取效率。     
对齐的作用和原因：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误,那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对 数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那 么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数 据。显然在读取效率上下降很多。



**一、成员变量的偏移量**     

定义结构体如下
```objc
struct stru1{
　　int i;      //4字节
　　char c;     //1字节
　　int j;      //4字节
}
```
偏移量：指的是结构体变量中成员的地址和结构体变量地址的差。   
结构体大小：等于最后一个成员的偏移量加上最后一个成员的大小。    

stru1(假设其地址为0x10182be10)的分布如下表：    

| 成员变量 | 成员变量地址 | 结构体地址 | 偏移量 | 大小 |
|int  i | 0x10182be10 | 0x10182be10 | 0 | 4 |
|char c | 0x10182be14 | 0x10182be10 | 4 | 1 |
|int  j | 0x10182be15 | 0x10182be10 | 5 | 4 |

但实际上，由于存储变量时地址对齐的要求，编译器在编译程序时会遵循两条原则：

1. 结构体变量中成员的偏移量必须是自身大小的整数倍（0被认为是任何数的整数倍） 
2. 结构体大小必须是所有成员大小的整数倍。

根据以上规则，int j变量不符合，调整如下：

| 成员变量 | 成员变量地址 | 结构体地址 | 偏移量 | 大小 |
|int  i | 0x10182be10 | 0x10182be10 | 0 | 4 |
|char c | 0x10182be14 | 0x10182be10 | 4 | 1 |
|int  j | 0x10182be18 | 0x10182be10 | 8 | 4 |     

<span style="color:red;">结构体大小等于最后一个成员的偏移量加上其大小，上面的例子中计算出来的大小为12，满足要求。</span>

**二、结构体的大小**

定义结构体如下
```objc
struct stru2{
　　int k;
　　short t;
}
```

| 成员变量 | 成员变量地址 | 结构体地址 | 偏移量 | 大小 |
|int  k | 0x10182be10 | 0x10182be10 | 0 | 4 |
|short t | 0x10182be14 | 0x10182be10 | 4 | 2 |

成员k的偏移量为0；成员t的偏移量为4，都不需要调整。但计算出来的大小为6，显然不是成员k大小的整数倍。因此，编译器会在成员t后面补上2个字节，使得结构体的大小变成8从而满足第二个要求。由此可见，大家在定义结构体类型时需要考虑到字节对齐的情况，不同的顺序会影响到结构体的大小。

如下两种形式：    
形式一：   

```objc
　struct stru3{
　　char c1;
　　int i;
　　char c2;
}
```

| 成员变量 | 成员变量地址 | 结构体地址 | 偏移量 | 大小 |
|char c1 | 0x10182be10 | 0x10182be10 | 0 | 1 |
|int i | 0x10182be14 | 0x10182be10 | 4 | 4 |
|char c2 | 0x10182be18 | 0x10182be10 | 8 | 1 |

<span style="color:red">结构体的大小为12字节</span>

形式二：   

```objc
　struct stru4{
　　char c1;
   char c2;
　  int i;
}
```

| 成员变量 | 成员变量地址 | 结构体地址 | 偏移量 | 大小 |
|char c1 | 0x10182be10 | 0x10182be10 | 0 | 1 |
|char c2 | 0x10182be11 | 0x10182be10 | 1 | 1 |
|int i | 0x10182be14 | 0x10182be10 | 4 | 4 |

<span style="color:red">结构体的大小为8字节</span>


**三、嵌套类型的结构体大小和成员偏移量**     
定义结构体如下：

```objc
struct stru5{
　　short i;

　　struct{
　　  char c;
　　  int j;
　　} ss;

　　int k;
}
```

如果结构体中的成员又是另外一种结构体类型时应该怎么计算呢？只需把其展开即可。但有一点需要注意，展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大的成员的整数倍.

| 成员变量 | 成员变量地址 | 结构体地址 | 偏移量 | 大小 |
|shor i | 0x10182be10 | 0x10182be10 | 0 | 2 |
|char c | 0x10182be14 | 0x10182be10 | 4 | 1 |
|int j | 0x10182be18 | 0x10182be10 | 8 | 4 |
|int k | 0x10182be1c | 0x10182be10 | 12 | 4 |

<span style="color:red">结构体stru5的成员ss.c的偏移量应该是4，而不是 2。整个结构体大小应该是16。</span>

----------
>  行者常至，为者常成！


