---
layout: post
title: "RunLoop(2)"
date: 2018-07-16
description: "RunLoop"
tag: Objective-C
---


- [墙裂推荐：深入理解RunLoop](https://blog.ibireme.com/2015/05/18/runloop/)


## 目录
* [runloop 与 定时器](#content1)
* [runloop 与 gcd](#content2)
* [runloop 与 selector](#content3)
* [runloop 与 UI刷新等](#content4)







<!-- ************************************************ -->
## <a id="content1">runloop 与 定时器</a>

#### **一、解决NSTimer在scrollview滚动时不调用的问题**      

```objc
//该timer 只能在NSDefaultRunLoopMode模式下工作
//当程序中有ScrollView滑动时 runloop 会在 UITrackingRunLoopMode 模式下运行，此时timer就失效了
NSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {
    NSLog(@"timer调用");
}];

//解决办法 将该timer也添加到 UITrackingRunLoopMode
[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];

//或者 NSRunLoopCommonModes 不是一个具体的模式，代表多个模式的集合
[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
```

```objc
//该timer默认没有加入到任何Mode下 所以直接这么写是不会触发timer的事件的
NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {
    NSLog(@"timer调用");
}];

//在默认模式下 运行timer
[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];

//在追踪模式下 运行timer
[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];

//在多模式下 运行timer
[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
```

#### **二、NSTimer不准时，gcd的定时器比较准**   

NSTimer并不能完全保证准时，当runloop的任务过重时或被阻塞时，可能错误timer的调用时机，导致timer不准确    

Grand Central Dispatch（GCD）是苹果提供的一个用于并发编程的框架，其中的dispatch_source_t类型可以用于创建定时器。

GCD 定时器相对于一些其他定时器实现（比如NSTimer）更加准时的原因是：

GCD 定时器是基于系统时钟的，因此它更精确。它使用系统底层的时钟机制，不受主运行循环模式的限制，因此可以提供更准确的定时器。


<!-- ************************************************ -->
## <a id="content2">runloop 与 gcd</a>

```objc
dispatch_async(dispatch_get_main_queue(), ^{
    NSLog(@"current3  %@",[NSThread currentThread]);
});
```

当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒


<!-- ************************************************ -->
## <a id="content3">runloop 与 selector</a>

下面的两个方法依赖运行循环      
```objc
// 从调用栈看，是source0
[self performSelector:@selector(test1) onThread:currentThread withObject:nil waitUntilDone:NO];

// 也是timer事件，依赖runloop,所以如果当前线程没有 RunLoop，则这个方法会失效
[self performSelector:@selector(test1) withObject:nil afterDelay:0];
```


<!-- ************************************************ -->
## <a id="content4">runloop 与 UI刷新等</a>







----------
>  行者常至，为者常成！


