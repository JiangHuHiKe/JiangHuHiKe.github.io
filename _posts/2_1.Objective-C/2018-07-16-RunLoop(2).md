---
layout: post
title: "RunLoop(2)"
date: 2018-07-16
description: "RunLoop"
tag: Objective-C
---


- [墙裂推荐：深入理解RunLoop](https://blog.ibireme.com/2015/05/18/runloop/)


## 目录
* [runloop 与 定时器](#content1)
* [runloop 与 gcd](#content2)
* [runloop 与 selector](#content3)
* [runloop 与 UI刷新等](#content4)
* [runloop 与 事件响应和手势](#content5)
* [runloop 与 autoreleasePool](#content6)



<!-- ************************************************ -->
## <a id="content1">runloop 与 定时器</a>

#### **一、timer**   

timer 事件会唤醒runloop       

下面代码的本质也是timer      
```objc
[self performSelector:@selector(test1) withObject:nil afterDelay:0];
```


#### **二、解决NSTimer在scrollview滚动时不调用的问题**      

```objc
//该timer 只能在NSDefaultRunLoopMode模式下工作
//当程序中有ScrollView滑动时 runloop 会在 UITrackingRunLoopMode 模式下运行，此时timer就失效了
NSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {
    NSLog(@"timer调用");
}];

//解决办法 将该timer也添加到 UITrackingRunLoopMode
[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];

//或者 NSRunLoopCommonModes 不是一个具体的模式，代表多个模式的集合
[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
```

```objc
//该timer默认没有加入到任何Mode下 所以直接这么写是不会触发timer的事件的
NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {
    NSLog(@"timer调用");
}];

//在默认模式下 运行timer
[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];

//在追踪模式下 运行timer
[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];

//在多模式下 运行timer
[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
```

#### **三、NSTimer不准时，gcd的定时器比较准**   

NSTimer并不能完全保证准时，当runloop的任务过重时或被阻塞时，可能错误timer的调用时机，导致timer不准确    

Grand Central Dispatch（GCD）是苹果提供的一个用于并发编程的框架，其中的dispatch_source_t类型可以用于创建定时器。

GCD 定时器相对于一些其他定时器实现（比如NSTimer）更加准时的原因是：

GCD 定时器是基于系统时钟的，因此它更精确。它使用系统底层的时钟机制，不受主运行循环模式的限制，因此可以提供更准确的定时器。


<!-- ************************************************ -->
## <a id="content2">runloop 与 gcd</a>

```objc
dispatch_async(dispatch_get_main_queue(), ^{
    NSLog(@"current3  %@",[NSThread currentThread]);
});
```

当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒


<!-- ************************************************ -->
## <a id="content3">runloop 与 selector</a>

下面的两个方法依赖运行循环      
```objc
// 从调用栈看，是source0
[self performSelector:@selector(test1) onThread:currentThread withObject:nil waitUntilDone:NO];

// 也是timer事件，依赖runloop,所以如果当前线程没有 RunLoop，则这个方法会失效
[self performSelector:@selector(test1) withObject:nil afterDelay:0];
```


<!-- ************************************************ -->
## <a id="content4">runloop 与 UI刷新等</a>

当在操作UI时，比如改变了Frame、更新了 UIView/CALayer 的层次时，    
或者手动调用了 UIView/CALayer的 setNeedsLayout/setNeedsDisplay方法后，    
这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。    

苹果注册了一个 Observer监听 **BeforeWaiting(即将进入休眠)** 和 **Exit (即将退出Loop)**事件，   
回调去执行一个很长的函数：_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。   
这个函数里会遍历所有待处理的 UIView/CAlayer以执行实际的绘制和调整，并更新 UI 界面。     

这个函数内部的调用栈大概是这样的：
```objc
_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()
    QuartzCore:CA::Transaction::observer_callback:
        CA::Transaction::commit();
            CA::Context::commit_transaction();
                CA::Layer::layout_and_display_if_needed();
                    CA::Layer::layout_if_needed();
                        [CALayer layoutSublayers];
                            [UIView layoutSubviews];
                    CA::Layer::display_if_needed();
                        [CALayer display];
                            [UIView drawRect];
```

<!-- ************************************************ -->
## <a id="content5">runloop 与 事件响应和手势</a>

#### **一、事件响应**     

苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。

当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。    
SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。    
随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。    

_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。
通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。      


#### **二、手势识别**      

当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。
随后系统将对应的 UIGestureRecognizer 标记为待处理。    

苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，    
这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，    
并执行GestureRecognizer的回调。    

当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。



<!-- ************************************************ -->
## <a id="content6">runloop 与 autoreleasePool</a>


App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。

第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。    
其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。    

第二个 Observer 监视了两个事件：      
BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；     
Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。   
这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。    

在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。     
这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。    

<img src="/images/objectC/objc11.webp">



----------
>  行者常至，为者常成！


