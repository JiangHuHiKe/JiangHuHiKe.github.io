---
layout: post
title: "RunLoop(1)"
date: 2018-07-15
description: "RunLoop"
tag: Objective-C
---


- [参考文章：iOS底层原理 - RunLoop总结](https://www.jianshu.com/p/b55a7f9969ae)


## 目录
* [介绍](#content1)
* [runloop与线程](#content2)
* [runloop相关类](#content3)
* [runloop的源](#content4)
* [runloop的运行逻辑](#content5)
* [主线程的runloop在哪启动](#content6)



<!-- ************************************************ -->
## <a id="content1">概览</a>

#### **一、介绍**
run loop 是一个事件处理循环，用来不停的调度工作以及处理输入事件。<br>
RunLoop的基本作用<br>
保持程序的持续运行<br>
处理App中的各种事件（比如触摸事件、定时器事件等）<br>
节省CPU资源，提高程序性能：该做事时做事，该休息时休息<br>

#### **二、应用范畴**
定时器（Timer）、PerformSelector<br>
GCD Async Main Queue<br>
事件响应、手势识别、界面刷新<br>
网络请求<br>
AutoreleasePool<br>

#### **三、实际开发中的应用**
控制线程生命周期（线程保活）<br>
解决NSTimer在滑动时停止工作的问题<br>
监控应用卡顿<br>
性能优化<br>


#### **四、runloop的驱动**
你的代码要提供实现循环部分的控制语句，换言之就是要有 while 或 for 循环语句来驱动 run loop。


<!-- ************************************************ -->
## <a id="content2">runloop与线程</a>

每条线程都有唯一的一个与之对应的RunLoop对象<br>
RunLoop保存在一个全局的Dictionary里，线程作为key，RunLoop作为value<br>
线程刚创建时并没有RunLoop对象，RunLoop会在第一次获取它时创建<br>
RunLoop会在线程结束时销毁<br>
主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop<br>



<!-- ************************************************ -->
## <a id="content3">runloop相关类</a>

<img src="/images/objectC/loop1.png">

一个RunLoop包含<span style="color:red">若干个</span>Mode<br>
RunLoop启动时只能选择其中一个Mode，作为currentMode<br>
每个Mode又包含<span style="color:red">若干个</span>Source0/Source1/Timer/Observer<br>
请注意__CFRunLoopMode下的属性都是set 和 array

#### **一、CFRunLoopModeRef**

**1、介绍**
CFRunLoopModeRef代表RunLoop的运行模式

RunLoop启动时只能选择其中一个Mode，作为currentMode

如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入

不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响

如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出

**2、常见的Mode**

kCFRunLoopDefaultMode:NSDefaultRunLoopMode）：App的默认Mode，通常主线程是在这个Mode下运行

UITrackingRunLoopMode:界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响

NSRunLoopCommonModes:不是一个具体的模式，代表多个模式的集合

#### **二、CFRunLoopObserverRef**

<img src="/images/objectC/loop2.png">

注册的 run loop 观察者(run-loop Observers)可以收到这些通知，并在线程上面使用它们来做额外的处理。<br>
run loop 观察者可以只用一次或循环使用。若只用一次，那么在 它启动后，会把它自己从 run loop 里面移除，而循环的观察者则不会。你在创建 run loop 观察者的时候需要指定它是运行一次还是多次。<br>
```objc
void observeRunLoopActicities(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info){
    switch (activity) {
        case kCFRunLoopEntry:
            NSLog(@"kCFRunLoopEntry");
            break;
        case kCFRunLoopBeforeTimers:
            NSLog(@"kCFRunLoopBeforeTimers");
            break;
        case kCFRunLoopBeforeSources:
            NSLog(@"kCFRunLoopBeforeSources");
            break;
        case kCFRunLoopBeforeWaiting:
            NSLog(@"kCFRunLoopBeforeWaiting");
            break;
        case kCFRunLoopAfterWaiting:
            NSLog(@"kCFRunLoopAfterWaiting");
            break;
        case kCFRunLoopExit:
            NSLog(@"kCFRunLoopExit");
            break;
        default:
            break;
    }
}

// 创建Observer
CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, observeRunLoopActicities, NULL);
// 添加Observer到RunLoop中
CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);
// 释放
CFRelease(observer);
```

<!-- ************************************************ -->
## <a id="content4">runloop的源</a>

#### **一、输入源**

Source1 : 基于Port的线程间通信，通过内核和其他线程相互发送消息（与内核相关），系统自动触发

Source0 : 非基于port的，用户主动触发的事件（触摸事件，PerformSelectors），需要手动触发


#### **二、定时源**

runloop与定时器的关系，gcd定时器为什么精准



<!-- ************************************************ -->
## <a id="content5">runloop的运行逻辑</a>

<img src="/images/thread/loop1.png" alt="img">

<img src="/images/objectC/loop3.png">

<img src="/images/objectC/loop4.png">


<!-- ************************************************ -->
## <a id="content6">主线程的runloop在哪启动</a>

UIApplicationMain函数内启动了Runloop，程序不会马上退出，而是保持运行状态。因此每一个应用必须要有一个runloop，我们知道主线程一开起来，就会跑一个和主线程对应的RunLoop，那么RunLoop一定是在程序的入口main函数中开启。

<img src="/images/objectC/loop5.png">

运行程序，我们发现只会打印开始，并不会打印结束，这说明在UIApplicationMain函数中，开启了一个和主线程相关的RunLoop，导致UIApplicationMain不会返回，一直在运行中，也就保证了程序的持续运行。

我们来看到RunLoop的源码
<img src="/images/objectC/loop6.png">
我们发现RunLoop确实是do while通过判断result的值实现的。因此，我们可以把RunLoop看成一个死循环。如果没有RunLoop，UIApplicationMain函数执行完毕之后将直接返回，也就没有程序持续运行一说了。





----------
>  行者常至，为者常成！


