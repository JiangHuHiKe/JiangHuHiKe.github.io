---
layout: post
title: "第二章 Blocks(二)"
date: 2018-04-05
description: "Blocks"
tag: Objective-C高级编程：iOS与OS X多线程和内存管理
---


<h6>
  版权声明：本文为博主原创文章，未经博主允许不得转载。
  <a target="_blank" href="https://jianghuhike.github.io/1845.html">
  原文地址：https://jianghuhike.github.io/1845.html 
  </a>
</h6>



## 目录

* [Block的本质](#content1)
* [带参数的Block的本质](#content2)
* [变量捕获](#content3)



<!-- ************************************************ -->
## <a id="content1"></a>Block的本质 

针对以下代码，我们来窥探下block的本质    
```objc
int main(int argc, char * argv[]) {
    @autoreleasepool {
        
        void(^blk)(void)= ^(void){
            printf("Block\n");
        };
        blk();

    }
    return 0;
}
```
执行指令：xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m 并精简代码

```objc
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

struct __block_impl {
  void *isa;
  int Flags;
  int Reserved;
  void *FuncPtr;
};

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
    printf("Block\n");
}

int main(int argc, char * argv[]) {
        void(*blk)(void)= &__main_block_impl_0(
                                               __main_block_func_0,
                                               &__main_block_desc_0_DATA));
        ((__block_impl *)blk)->FuncPtr(blk);
    }
    return 0;
}
```

从以上源码分析：    
变量blk是指向结构体__main_block_impl_0的指针。  
1.__main_block_impl_0结构体的FuncPtr是指向函数__main_block_func_0的指针。    
2.__main_block_impl_0结构体的Desc是指向结构体__main_block_desc_0_DATA的指针。      
3.__main_block_impl_0结构体的Flags没有传值，那么就是默认值0。     
4.__main_block_impl_0结构体的isa是&_NSConcreteStackBlock，后面详细说明。       

函数__main_block_func_0    
1.封装了Block内要执行的表达式代码。    
2.参数就是__main_block_impl_0结构体地址。    

结构体 __main_block_desc_0     
1.成员变量 reserved 传入的是固定值0     
2.成员变量 Block_size 传入的是结构体__main_block_impl_0的大小     

<span style="color:red">从以上分析可以看出Block的本质是OC对象，内部封装了isa指针，调用函数，及自身大小。</span>


<!-- ************************************************ -->
## <a id="content2"></a>带参数的Block的本质  

```objc
int main(int argc, char * argv[]) {
    @autoreleasepool {
        
        void(^blk)(int)= ^(int a){
          printf("Block\n a=%d\n",a);
        };
        
        blk(10);
    }
    return 0;
}
```
同样执行指令：xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m 并精简代码
```objc
struct __main_block_impl_0 {
    struct __block_impl impl;
    struct __main_block_desc_0* Desc;
    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
        impl.isa = &_NSConcreteStackBlock;
        impl.Flags = flags;
        impl.FuncPtr = fp;
        Desc = desc;
    }
};

struct __block_impl {
  void *isa;
  int Flags;
  int Reserved;
  void *FuncPtr;
};

static struct __main_block_desc_0 {
    size_t reserved;
    size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};

static void __main_block_func_0(struct __main_block_impl_0 *__cself, int a) {
    printf("Block\n a=%d\n",a);
}

int main(int argc, char * argv[]) {
        void(*blk)(int)= &__main_block_impl_0(
                                              __main_block_func_0,
                                              &__main_block_desc_0_DATA));
        ((__block_impl *)blk)->FuncPtr)(blk, 10);
    }
    return 0;
}
```
<span style="color:red">我们看到，blk的调用和__main_block_func_0函数定义发生了变化都多出了一个int参数。</span>


<!-- ************************************************ -->
## <a id="content3"></a>变量捕获
我们看下为什么打印出来的age是10而不是20.     
```objc
int main(int argc, char * argv[]) {
    @autoreleasepool {
        
        int age = 10;
        
        void(^blk)(void)= ^(void){
            printf("Block\n age=%d\n",age);
        };
        
        age = 20;
        
        blk();
    }
    return 0;
}
```

同样执行指令：xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m 并精简代码

```objc
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  int age;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

struct __block_impl {
  void *isa;
  int Flags;
  int Reserved;
  void *FuncPtr;
};

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
    int age = __cself->age; // bound by copy
    
    printf("Block\n age=%d\n",age);
}

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};

int main(int argc, char * argv[]) {

        int age = 10;

        void(*blk)(void)=&__main_block_impl_0(
                                              __main_block_func_0,
                                              &__main_block_desc_0_DATA,
                                              age));

        age = 20;

       ((__block_impl *)blk)->FuncPtr)(blk);
    }
    return 0;
}
```

我们看到结构体__main_block_impl_0的定义发生了变化，多了一个age的成员变量，并且age的赋值发生在构造函数__main_block_impl_0调用时，并且传进去的值是10。      
再来看一下函数__main_block_func_0的实现，其内部有一个局部变量 `int age = __cself->age;`可知这个age的值也是10。    
后面的age=20;并不会影响__main_block_impl_0函数内部的局部变量age的值，所以打印出来的是10，而不是20。     



----------
>  行者常至，为者常成！


