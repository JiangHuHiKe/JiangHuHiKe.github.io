---
layout: post
title: "第二章 线程管理"
date: 2018-03-14 
description: "线程管理"
tag: 多线程编程指南
---


<h6>
  <img src="https://robotkang-1257995526.cos.ap-chengdu.myqcloud.com/icon/copyright.png" alt="copyright" style="display:inline;margin-bottom: -5px;" width="20" height="20"> 版权声明：本文为博主原创文章，未经博主允许不得转载。

  <a target="_blank" href="https://jianghuhike.github.io/18314.html">
  原文地址：https://jianghuhike.github.io/18314.html 
  </a>
</h6>

<!-- - [参考文章：https://jianghuhike.github.io/1811.html](https://jianghuhike.github.io/1811.html) -->


**参考书籍 《多线程编程指南》**   
**原著:Apple Inc.**    
**翻译:謝業蘭 【老狼】**   



## 目录
* [线程成本](#content0)
* [创建一个线程](#content1)
* [配置线程属性](#content2)
* [编写你线程的主体入口点](#content3)


每个应用程序启动时候都是一个线程，它执行程序的 main 函数。 应用程序可以生成额外的线程，其中每个线程执行一个特定功能的代码。   
每个线程都拥有它自己的执行堆栈，由内核调度独立的运行时间片。   
一个线程可以和其他线程或其他进程通信，执行 I/O 操作，甚至执行任何你想要它完成的任务。 因为它们处于相同的进程空间，所以一个独立应用程序里面的所有线程共享相同的虚拟内存空间，并且具有和进程相同的访问权限。

## <a id="content0"></a> 线程成本
**一、性能成本**   
每个线程都需要分配一定的内核内存和应用程序内存空间的内存。这些数据结构里面的大部分都是当你首次创建线程或者进程的时候被创建和初始化的，它们所需的代价成本很高，因为需要和内核交互。   
1.管理你的线程和协调其调度所需的核心数据结构存储在使用 Wired Memory 的内核里面。   
2.你线程的堆栈空间和每个线程的数据都被存储在你应用程序的内存空间里面。   


注意:因为底层内核的支持，操作对象(Operation objectis)可能创建线程更快。它们使用内核里面常驻线程池里面的线程来节省创建的时间，而不是每次都创建新的线程。

**二、生产成本**   
当编写线程代码时另外一个需要考虑的成本是生产成本。设计一个线程应用程序有时会需要根本性改变你应用程序数据结构的组织方式。


## <a id="content1"></a> 创建一个线程
在所有情况下，你必须有一个函数或方法作为线程的主入口点，你必须使用一个可用的线程来启动你的线程。 

**一、使用NSThread**   
方式一：创建一个脱离线程
```objc
NSThread detachNewThreadSelector:@selector(myThreadMainMethod:) toTarget:self withObject:@"test"];

-(void)myThreadMainMethod:(id)obj{
    //obj=test
    NSLog(@"obj=%@",obj);
    
    //thread = <NSThread: 0x126d8ef70>{number = 3, name = (null)}
    NSLog(@"thread = %@",[NSThread currentThread]);
}
```

方式二：创建一个脱离线程
```objc
NSThread * myThread = [[NSThread alloc] initWithTarget:self selector:@selector(myThreadMainMethod:) object:@"test"];

[myThread start];

-(void)myThreadMainMethod:(id)obj{
    //obj=test
    NSLog(@"obj=%@",obj);
    
    //thread = <NSThread: 0x126d8ef70>{number = 3, name = (null)}
    NSLog(@"thread = %@",[NSThread currentThread]);
}
```


**二、使用POSIX的多线程**    
该方式创建的线程可跨平台，仅作了解。


**三、使用NSObject来生成一个线程**    
```objc
ViewController * myObject = [[ViewController alloc] init];

[myObject performSelectorInBackground:@selector(myThreadMainMethod:) withObject:@"test"];

-(void)myThreadMainMethod:(id)obj{
    //obj=test
    NSLog(@"obj=%@",obj);
    
    //thread = <NSThread: 0x126d8ef70>{number = 3, name = (null)}
    NSLog(@"thread = %@",[NSThread currentThread]);
}
```



## <a id="content2"></a> 配置线程属性
创建线程之后或之前，你可能需要配置不同的线程环境。


**一、配置线程的堆栈大小**   
对于每个你新创建的线程，系统会在你的进程空间里面分配一定的内存作为该线 程的堆栈。该堆栈管理堆栈帧，也是任何线程局部变量声明的地方。给线程分配的内 存大小在“线程成本”里面已经列举了。
```objc
NSThread * myThread = [[NSThread alloc] initWithTarget:self selector:@selector(myThreadMainMethod:) object:@"test"];
    
NSLog(@"stackSize = %zd",myThread.stackSize);//stackSize = 524288d

//This value must be in bytes and a multiple of 4KB.
//To change the stack size, you must set this property before starting your thread. 
[myThread setStackSize:2097152];

NSLog(@"stackSize = %zd",myThread.stackSize);//stackSize = 2097152d

[myThread start];
```

**二、配置线程本地存储**    
每个线程都维护了一个键-值的字典，它可以在线程里面的任何地方被访问。
```objc
NSThread * myThread = [[NSThread alloc] initWithTarget:self selector:@selector(myThreadMainMethod:) object:@"test"];
    
[myThread.threadDictionary setObject:@"mythread" forKey:@"name"];

[myThread start];

-(void)myThreadMainMethod:(id)obj{
  /**
  dic={
    name = mythread;
  }
  */
  NSLog(@"dic=%@",[NSThread currentThread].threadDictionary);
}
```


**三、设置线程的脱离状态**   
脱离线程(Detached thread)允许系统在线程完成的时候立即释放它的数据结构。
可连接线程(Joinable thread)资源被系统回收之前必须被其他线程连接。可连接线程同时提供了一个显示的方式来把数据从一个正在退出的线程传递到其他线程。

重要:在应用程序退出时，脱离线程可以立即被中断，而可连接线程则不可以。每个可连接 线程必须在进程被允许可以退出的时候被连接。所以当线程处于周期性工作而不允许被中断的时 候，比如保存数据到硬盘，可连接线程是最佳选择。

如果你想要创建可连接线程，唯一的办法是使用 POSIX 线程。


**四、设置线程的优先级**   
你创建的任何线程默认的优先级是和你本身线程相同。内核调度算法在决定该运 行那个线程时，把线程的优先级作为考量因素，较高优先级的线程会比较低优先级的 线程具有更多的运行机会。较高优先级不保证你的线程具体执行的时间，只是相比较 低优先级的线程，它更有可能被调度器选择执行而已。

重要:让你的线程处于默认优先级值是一个不错的选择。增加某些线程的优先级，同时有可 能增加了某些较低优先级线程的饥饿程度。如果你的应用程序包含较高优先级和较低优先级线 程，而且它们之间必须交互，那么较低优先级的饥饿状态有可能阻塞其他线程，并造成性能瓶颈。

如果你想改变线程的优先级，Cocoa 和 POSIX 都提供了一种方法来实现。对于 Cocoa 线程而言，你可以使用 NSThread 的 setThreadPriority:类方法来设置当前运 行线程的优先级。对于 POSIX 线程，你可以使用 pthread_setschedparam 函数来实现。 关于更多信息，参与 NSThread Class Reference 或 pthread_setschedparam 主页。

```objc
NSThread * myThread = [[NSThread alloc] initWithTarget:self selector:@selector(myThreadMainMethod:) object:@"test"];

NSLog(@"threadPriority=%lf",myThread.threadPriority);//threadPriority=0.500000

[myThread setThreadPriority:1.0];

NSLog(@"threadPriority=%lf",myThread.threadPriority);//threadPriority=1.000000

[myThread start];
```

## <a id="content3"></a> 编写你线程的主体入口点



----------
>  行者常至，为者常成！


