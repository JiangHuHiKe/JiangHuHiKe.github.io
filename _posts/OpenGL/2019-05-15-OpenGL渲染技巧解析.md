---
layout: post
title: "OpenGL渲染技巧解析"
date: 2019-05-15
description: "OpenGL渲染技巧解析"
tag: OpenGL
---


<h6>
  版权声明：本文为博主原创文章，未经博主允许不得转载。
  <a target="_blank" href="https://jianghuhike.github.io/19515.html">
  原文地址：https://jianghuhike.github.io/19515.html 
  </a>
</h6>





## 目录
- [正背面剔除](#content1) 
- [深度测试](#content2) 
- [裁剪](#content3) 
- [颜色混合](#content3) 


<!-- ************************************************ -->
## <a id="content1"></a>正背面剔除

<!-- - [参考文章：OpenGL 图元](https://www.jianshu.com/p/a9598257a607) -->


<!-- ************************************************ -->
## <a id="content2"></a>深度测试

- [参考文章：OpenGL 深度测试](https://www.jianshu.com/p/2882088c2740)

**一、深度与深度缓存区**

1、什么叫深度

深度其实就是该像素点在3D世界中距离摄像机的距离,在坐标系中,像素Z坐标距离观察者的距离，Z值.

2、什么叫深度缓存区

深度缓存区,就是⼀块内存区域,专⻔存储着<span style="color:red">每个像素点</span>(绘制在屏幕上的)深度值.深度值(Z值)越⼤, 则离摄像机就越远.

3、深度缓冲区作用

在不使用深度测试的时候,如果我们先绘制⼀个距离⽐较近的物体,再绘制距离较远的物体,则距离远的位图因为后绘制,会把距离近的物体覆盖掉. 有了深度缓冲区后,绘制物体的顺序就不那么重要了. 实际上,只要存在深度缓冲区,OpenGL 都会把像素的深度值写入到缓冲区中. 除非调⽤用 glDepthMask(GL_FALSE).来禁止写入.


**二、深度测试**

1、什么是深度测试

深度缓存区（DepthBuffer）和颜色缓存区（ColorBuffer）是对应的。颜色缓存区存储像素的颜色信息,⽽深度缓冲区存储像素的深度信息. 在决定是否绘制一个物体表面时, 首先要将表⾯对应的像素的深度值与当前深度缓冲区中的值进⾏比较. 如果⼤于深度缓冲区中的值,则丢弃这部分，否则就使⽤这个像素对应的深度值和颜⾊值，分别更新深度缓冲区和颜⾊缓存区. 这个过程称为”深度测试”

深度缓冲区,⼀般由窗⼝管理系统,GLFW创建.深度值⼀般由16位,24位,32位值表示. 通常是24位.位数越高,深度精确度更好.

开启深度测试    
glEnable(GL_DEPTH_TEST);

关闭深度测试      
glDisable(GL_DEPTH_TEST);

在绘制场景前,清除颜色缓存区,深度缓冲区     
glClearColor(0.0f,0.0f,0.0f,1.0f);     
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);   
清除深度缓冲区默认值为1.0,表示最⼤的深度值,深度值的范围为(0,1)之间. 值越⼩表示越靠近观察者,值越⼤表示越远离观察者

void glDepthMask(GLBool value);      
value : GL_TURE 开启深度缓冲区写入; GL_FALSE 关闭深度缓冲区写⼊

2、深度测试判断模式

void glDepthFunc(GLEnum mode);

|函数|说明|
|GL_ALWAYS|总是通过测试|
|GL_NEVER|总是不通过测试|
|GL_LESS|在当前深度值 < 存储的深度值时通过|
|GL_EQUAL|在当前深度值 = 存储的深度值时通过|
|GL_LEQUAL|在当前深度值 <= 存储的深度值时通过|
|GL_GREATER|在当前深度值 > 存储的深度值时通过|
|GL_NOTHQUAL|在当前深度值 不等于 存储的深度值时通过|
|GL_GEQUAL|在当前深度值 >= 存储的深度值时通过|

默认值是GL_LESS



**三、ZFighting闪烁问题**

1、为什么会出现 ZFighting 闪烁问题

因为开启深度测试后,OpenGL 就不会再去绘制模型被遮挡的部分. 这样实现的显示更加真实.但是由于深度缓冲区精度的限制对于深度相差⾮常⼩的情况下.(例如在同⼀平⾯上进行2次绘制),OpenGL 就可能出现不能正确判断两者的深度值,会导致深度测试的结果不可预测.显示出来的现象是交错闪烁.前⾯2个画面,交错出现.

<img src="/images/OpenGL/opengl2.png" alt="img">

当我们的图形不是特别复杂时这种问题基本不会遇见。

这个问题可以通过 启⽤ Polygon Offset ⽅式解决，思路就是让深度值之间产⽣间隔.如果2个图形之间有间隔,是不是意味着就不会产⽣干涉.可以理解为在执⾏深度测试前将⽴方体的深度值做⼀些细微的增加.于是就能将重叠的2个图形深度值之间有所区分. 这里就不细说了

2、ZFighting闪烁问题预防

不要将两个物体靠的太近，避免渲染时三⻆形叠在⼀起。这种⽅式要求对场景中物体插⼊⼀个少量的偏移，那么就可能避免ZFighting现象。例如上⾯的⽴方体和平⾯中，将平⾯下移0.001f就可以解决这个问题。当然⼿动去插入这个⼩小的偏移是要付出代价的。 

尽可能将近裁剪⾯设置得离观察者远一些。上⾯我们看到，在近裁剪平面附近，深度的精确度是很⾼的，因此尽可能让近裁剪面远⼀些的话，会使整个裁剪范围内的精确度变高一些。但是这种方式会使离观察者较近的物体被裁减掉，因此需要调试好裁剪⾯参数。 

使用更高位数的深度缓冲区，通常使用的深度缓冲区是24位的，现在有一些硬件使⽤32位的缓冲区，使精确度得到提高




<!-- ************************************************ -->
## <a id="content3"></a>裁剪

<!-- - [参考文章：OpenGL 下固定管线着色器](https://www.jianshu.com/p/708ebb0c50da) -->


<!-- ************************************************ -->
## <a id="content4"></a>颜色混合


----------
>  行者常至，为者常成！


