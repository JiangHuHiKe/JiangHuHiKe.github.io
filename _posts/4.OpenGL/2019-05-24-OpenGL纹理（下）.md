---
layout: post
title: "7、OpenGL纹理（下）"
date: 2019-05-24
description: "OpenGL纹理（下）"
tag: OpenGL
---
 




## 目录
- [Mip贴图](#content1) 
- [各向异性过滤](#content2) 



<!-- ************************************************ -->
## <a id="content1"></a>Mip贴图

**一、什么是Mip贴图？**

Mip贴图（多级渐远纹理）

Mip贴图是一种功能强大的纹理技巧。他可以提高渲染性能同时可以改善场景的显示质量。

想象一下，假设我们有一个包含着上千物体的大房间，每个物体上都有纹理。有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。

由于远处的物体可能只产生很少的片段(远处的物体看起来很小，只需要很少的片段(像素))，OpenGL从高分辨率纹理中为这些片段获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段只拾取一个纹理颜色(想象着整个高分辨率的纹理图像贴在几个小片段上)，在小物体上这会产生不真实的感觉，更不用说对它们使用高分辨率纹理浪费内存的问题了。


OpenGL使用一种叫做多级渐远纹理(Mipmap)的概念来解决这个问题，它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理(就是分辨率递减的同一纹理)，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好，加载了大量的纹理数据之后，还要对其进行过滤处理（缩小）(我的理解是过滤只取纹理图像中的一部分，这是由纹理坐标决定的)，在屏幕上显示的只是一小部分。纹理越大，所造成的性能影响就越大。但同时它也会增加额外的内存，大约比原先多出1/3内存空间。让我们看一下多级渐远纹理是什么样子的：


<img src="/images/OpenGL/add1.png" alt="img">


手工为每个纹理图像创建一系列多级渐远纹理很麻烦，幸好OpenGL有一个glGenerateMipmaps函数，在创建完一个纹理后调用它OpenGL就会承担接下来的所有工作了。后面的教程中你会看到该如何使用它

<img src="/images/OpenGL/add2.png" alt="img">



**二、Mip贴图API**

```
//设置mip贴图基层 
glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_BASE_LEVEL,0);

//设置mip贴图最大层 
glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_LEVEL,0);

//加载Mip,纹理生成所有的Mip层
//参数：GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D
glGenerateMipmap(GL_TEXTURE_2D);
```

//具有非常好的性能，并且闪烁现象非常弱
#define GL_NEAREST_MIPMAP_NEAREST 0x2700

//常用于对游戏进行加速，它使用了高质量的线性过滤器
#define GL_LINEAR_MIPMAP_NEAREST 0x2701

//过滤器在Mip层之间执行了一些额外的插值，以消除他们之间的过滤痕迹
#define GL_NEAREST_MIPMAP_LINEAR 0x2702

//三线性Mip贴图。纹理过滤的黄金准则，具有最高的精度
#define GL_LINEAR_MIPMAP_LINEAR 0x2703


**三、过滤方式**

在渲染中切换多级渐远纹理级别(Level)时，OpenGL在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界。就像普通的纹理过滤一样，切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤。为了指定不同多级渐远纹理级别之间的过滤方式，你可以使用下面选项中的一个代替原有的过滤方式


|过滤方式|	描述|
|GL_NEAREST| 在Mip基层上执⾏行行最邻近过滤|
|GL_LINEAR| 在Mip基层执⾏行行线性过滤|
|GL_NEAREST_MIPMAP_NEAREST|	使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样|
|GL_LINEAR_MIPMAP_NEAREST|	使用最邻近的多级渐远纹理级别，并使用线性插值进行采样|
|GL_NEAREST_MIPMAP_LINEAR|	在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样|
|GL_LINEAR_MIPMAP_LINEAR|	在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样|

**一个常见的错误是，将放大过滤的选项设置为多级渐远纹理过滤选项之一。这样没有任何效果，因为多级渐远纹理主要是使用在纹理被缩小的情况下的：纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个GL_INVALID_ENUM错误代码。**



<!-- ************************************************ -->
## <a id="content2"></a>各向异性过滤

**一、什么是各向异性过滤**

各向异性纹理过滤（Anisotropic texture filtering）并不是OpenGL核心规范中的一部分，但它是一种得到广泛使用的扩展，可以极大提高纹理过滤操作的质量。
当一个纹理贴图被过滤时，OpenGL使用纹理坐标来判断一个特定的几何片段将落在纹理什么地方，然后紧邻这个位置的纹理单元使用GL_NEAREST和GL_LINEAR过滤操作进行采样。

**处理纹理过滤时，考虑了观察角度的过滤方法叫做各向异性过滤。**

<img src="/images/OpenGL/add3.png" alt="img">


各向同性采样：观察方向和观察点垂直时对纹理进行采样；
各向异性采样：以一定角度倾斜地观察几何图形，对周围纹理单元进行常规采样，这样会导致一些纹理信息丢失，图像看上去模糊。为了更加逼真和准确的采样，应该沿着包含纹理的平面方向进行延伸。在Mip贴图纹理过滤模型中，或者其他所有的基本纹理过滤都可以应用各向异性过滤。


**二、各向异性过滤API**

```
/第一，查询得到支持的各向异性过滤的最大数量
GLfloat flargest;
glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT,&fLargest); 

//第二，设置各向异性过滤
//设置纹理参数（各向异性采样）
glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MAX_ANISOTROPY_EXT,fLargest)

//回归同性过滤，设置各向同性过滤，数量为1.0表示各向同性采样
glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, 1.0f);
```

注意：各向异性过滤所应用的数量fLargest越大，沿着最大变化方向（沿着最强的观察点）所采样的纹理单元就越多。值1.0表示常规的纹理过滤（各向同性过滤）。
各向异性过滤会增加额外的工作，包括其他纹理单元。很可能对性能造成影响，但是在现代硬件上，应用这个特性对速度造成影响不大。
最重要的是，目前它已经成为流行游戏、动画和模拟程序的一个标准特性。









----------
>  行者常至，为者常成！


