---
layout: post
title: "Net概要"
date: 2023-09-05
tag: Overview
---





## 目录
* [1、基本概念](#content1)
* [2、基本概念（二）](#content2)
* [3、MAC_IP地址](#content3)
* [4、路由](#content4)
* [5、网络分层(物理层、链路层)](#content5)
* [6、网络层](#content6)
* [7、传输层](#content7)
* [8、TCP_可靠传输](#content8)
* [9、TCP_流量控制、拥塞控制](#content9)
* [10、TCP_序号、确认号](#content10)
* [11、连接、释放连接](#content11)
* [12、应用层](#content12)
* [13、HTTP](#content13)
* [14、HTTP（二）](#content14)
* [15、HTTP（三）](#content15)
* [16、HTTP（四）](#content16)
* [17、HTTP（五）](#content17)
* [18、网络安全](#content18)
* [19、HTTPS](#content19)
* [20、HTTP的升级改进](#content20)
* [21、其它协议](#content21)
* [22、补充](#content22)





<!-- ************************************************ -->
## <a id = "content1">1、基本概念</a>

#### **一、客户端与服务器通讯过程**

**1、服务端**   
搭建Java服务器开发环境    
项目创建   
项目部署到服务器软件，客户端才能访问到。    
部署可以理解为给服务器安装软件，只有部署了客户端才能访问到要访问的内容       


**2、客户端**    
只能由客户端发出请求<br>
https://128.10.10.12:8080/qq<br>
ip地址 + 端口号 + 项目<br>
IP地址找到服务器 + 服务器软件监听端口 + 同一个端口下可以有多个项目(qq   weixin  wangzhe)<br>



#### **二、语言夸平台的原理**
C语言编译成不同的格式<br>
Java编译成中间代码跑在虚拟机上<br>
JS浏览器的JS引擎解释执行<br>


#### **三、网络协议**
协议是双方沟通的基础，用来约束双方按一定的格式发消息<br>
协议需要国际化标准组织来制定<br>
协议促进了互联网的发展<br>
OSI网络参考模型


<!-- ************************************************ -->
## <a id = "content2">2、基本概念（二）</a>

#### **一、设备认识**

**1、集线器**   
无智商，将数据发给任何跟它相连的设备    

**2、网桥**    
只有两个接口    
可以记录接口一侧设备的Mac地址    
<span style="color:red;font-weight:bold">隔绝冲突域</span>    
缺点:接口太少同一接口侧仍然会有冲突    

**3、交换机**    
具有多个接口的网桥，每个接口的mac地址都知道         
局域网的最终解决方案    
全球计算机只有网桥连接会怎样？  
会产生广播风暴      

**4、路由**     
连接两个不同的网段     
<span style="color:red;font-weight:bold">隔绝广播域(连接不同网段)</span>     

现代的网络使用的是 **路由器 + 交换机**

#### **二、数据是如何传递的**     

<span style="color:red;font-weight:bold">网络是分层的，要在分层的基础上理解数据的传递</span>

**1、arp广播**     
arp网络层协议：通过广播获取目标ip地址主机的mac地址         
网络层：源ip地址，目标ip地址    
链路层：源mac地址，广播mac地址    
arp缓存：ip地址和mac地址的映射关系表     

如果a主机的ip地址ipa过期了，将ipa分配给了b主机,如果这是arp缓存没有更新，那么发送给b的数据都会发送给a。这也是网络安全的一部分，arp欺骗。

**2、icmp协议**    
icmp网络层协议：通过目标mac地址，数据交给交换机，交换机将数据发给mac地址对应的主机           
网络层：源ip地址，目标ip地址        
链路层：源mac地址，目标mac地址     
   
ip地址和mac地址的配合，将数据发送给目标主机   
ping 发出的是icmp数据包   


**3、如果数据要发送的不是同一个网段**    
arp广播会通过配置的网关的ip地址，拿到网关的mac地址     
icmp数据包会传递给网关      
网关负责将数据给到另一个网段     



<!-- ************************************************ -->
## <a id = "content3">3、MAC_IP地址</a>

#### **一、mac地址**  
6个字节 前三厂商标识后三自行分配   

#### **二、IP地址+子网掩码**   
网络号 + 主机号     
主机号全0代表网段    
主机号全1代表广播向这个网段所有主机发信息           

#### **三、网址分类**    
A类    
B类:128开头 128.0.0.0是第一个B类网段    
C类:192开头 192.0.0.0是第一个C类网段    

#### **四、等长子网划分**  
子网、超网、等长子网划分、变长子网划分    
不管是什么怎么划分，都是在A类、B类、C类的基础上进行的    
是否在一个网段通过子网掩码计算就可以了   
<span style="color:red;font-weight:bold">ip地址 + 子网掩码 搞定一切</span>     

下面的两个主机不在同一个网段     
192.168.0.0/25  和  192.168.0.128/25     

#### **五、一个很好的例子**
<img src="/images/Network/net10.png">
计算机0向计算机1发送数据，需要先看是否在同一个网段：拿自己的子网掩码与对方的ip地址进行计算(拿不到对方的子网掩码)    
计算机0的网段：192.168.0.0/24     
计算机1的网段：192.168.10.0/24    
不在同一个网段不是路由连接不能发送消息    

<img src="/images/Network/net11.png">
计算机1向计算机0发送消息，网段计算   
计算机1的网段：192.168.0.0/16   
计算机2的网段：192.168.0.0/16   
虽然计算后是同一个网段，但仍不能正常通讯，因为消息能发出但回不来    



<!-- ************************************************ -->
## <a id = "content4">4、路由</a>


#### **一、数据包的传输过程**
IP地址 Mac地址<br>
传输过程中源IP地址和目标IP地址不会变<br>
Mac地址会随着在不同链路传输进行变换<br>
数据从一台主机传递到另外一台主机是IP地址和Mac地址配合的结果<br>


#### **二、路由**    
路由默认只知道跟它直连的网段   
非直连的网段需要静态路由和动态路由告诉他    

动态路由:    
路由选择协议，一个路由器问另一个跟它直连的路由器，哎跟你直连的网段有哪些 这个路由就知道了这些网段。    
一直打听下去就知道了目标网段的存在，就知道了怎么走    

静态路由：      
手动配置      

<span style="color:red;font-weight:bold">本质都是路由表</span>

要去往非直连的网段 路由器需要知道下一跳的IP地址

#### **三、网关和下一跳**
数据从一个网段去往另一个网段需要先发送给设置好的网关(路由器)<br>
如果要去往的网段跟路由器直连，路由器就会将数据发送到网段<br>
如果要去往的网段没有跟路由器直连，路由会根据路由表设置的下一跳地址去往下一跳<br>
xy:在路由表中能找到所有网段要去往的下一跳<br>
动态路由技术(会实时更新路由表)使得发往同一个服务器的数据所穿过的路由路径可能会不同<br>


#### **四、NAT转换**
私网和公网：路由表只知道公网网段 不知道私网网段<br>
我的主机(私网ip)  -  路由(私网ip) … - 路由(公网ip) - Net<br>
私网ip在最后链接公网ip的那台路由进行NAT转换<br>

#### **五、几个私网网段**
所有10开头的都是A类私网   
172.16.0.0/16 ~ 172.31.0.0/16，16个B类私网   
所有192.168开头的都是C类私网      


<!-- ************************************************ -->
## <a id = "content5">5、网络分层(物理层、链路层)</a>

#### **一、小知识点**
1 不同路由器效果不同<br>
一般路由器是连接不同的网段，但有的路由器可以连接相同的网段(了解)

2 为什么ping的时候第一次会超时<br>
第一次要通过ARP广播获取Mac地址，路由器忙不过来会把数据包给扔了，所以第一次会超时

#### **二、网络互联模型介绍**
**1、物理层**<br>
物理层设备：网线、集线器、交换机、网卡、路由器<br>
模拟信号 数字信号<br>
单工通讯(广播) 半双工通讯(对讲机) 全双工通讯(电话)

**2、链路层**<br>

<img src="/images/Network/osi10.png" alt="img">

两个节点之间叫做链路，路由器和交换机、路由器和路由器<br>
封装成帧<br>
透明传输<br>
差错检测<br>

<img src="/images/Network/osi11.png" alt="img">

不同的链路使用的协议不一样，比如路由器跟交换机直连的链路和路由器跟路由器之间的链路。但他们都有上边说的三部分，只是协议不同数据格式不同<br>
广播信道使用csma/cd协议 有Mac地址<br>
点对点信道使用ppp协议 无Mac地址<br>

#### **三、设备都工作在哪层**
路由器:物理层 链路层 网络层<br>
网卡:二层网络设备，工作在链路层和物理层，数据交给网卡后会进行差错检验,检验合格丢弃FCS向上传递，检验不合格丢弃数据<br>
交换机:物理层 链路层<br>
集线器:物理层<br>



<!-- ************************************************ -->
## <a id = "content6">6、网络层</a>


#### **一、IP首部图片示例**

<img src="/images/Network/net1.png" alt="img">

标识：数据包的id   
标志：保留 + 是否分片(DF) + 是否最后一片(MF)    
片偏移:位于整个数据包的哪个位置       

#### **二、首部协议标识**

协议：封装的数据部分使用的什么协议，比如传输层过来的 tcp 和 udp、网络层产生的 arp 和 icmp

arp协议工作在网络层<br>
<img src="/images/Network/ip18.png">

icmp协议工作在网络层<br>
我们ping的时候是没有经过应用层和传输层的 <br>
IP首部 + icmp首部 + 数据<br>
<img src="/images/Network/ip19.png">

类似的协议还有:<br>
ppp 协议工作在链路层<br>
csma/cd 协议工作在链路层<br>


#### **三、TTL**

生存时间，允许传过路由器的数量，当ttl变为0时，对应的路由器会返回错误报文        
通过ping命令，配置ttl，可以逐步查看穿过的路由器    



<!-- ************************************************ -->
## <a id = "content7">7、传输层</a>

#### **一、UDP**

**1、udp协议首部示例**
<img src="/images/Network/udp1.png" alt="img">


**2、端口**

客户端端口临时随机开启<br>
服务端端口不同协议有不同端口<br>
防火墙可以禁用某些端口来达到禁止访问的目的 比如数据库协议<br>

<img src="/images/Network/udp5.png" style="height:300px">

#### **二、TCP**

<img src="/images/Network/tcp1.png" alt="img">




<!-- ************************************************ -->
## <a id = "content8">8、TCP_可靠传输</a>

#### **一、可靠传输**

**1、最开始的可靠传输实现方式：ARQ（Automatic Repeat-reQuest）协议**<br>
停止等待 + 超时重传<br>
存在的问题：每发送一次数据，都要等待确认，时间过长。<br>
比如分片数据发送后要等待1s收到确认再发送下一片,那么发送10个分片数据的时间就是10s<br>

**2、现在的解决方式：ARQ协议 + 滑动窗口协议**<br>
停止等待 + 超时重传 +  滑动窗口<br>
一次发送多个分片数据,通过确认号来确认收到的数据<br>
分片数据发送多少是由首部的窗口大小决定的，窗口大小是动态变化的,在发送过程中会互相告诉对方<br>

**3、选择确认**<br>
首部的选项部分可以存储收到了哪些数据，可以减少重传，提高传输效率

**4、序号**<br>
两次分片数据的序列号之差算出的是数据部分的大小，不包括首部<br>
每次连接都会有一个初始序列号<br>
tcp链接有自己的一套随机算法，保证不同链接的序号不会重合<br>

**5、分片**<br>
大文件传输，在传输层已经大卸八块，不会轮到网络层再分片    
为什么在传输层就进行分片？    

**6、看看本篇最后的几个思考**     




<!-- ************************************************ -->
## <a id = "content9">9、TCP_流量控制、拥塞控制</a>

##### **一、流量控制**
为什么要进行流量控制？   
接收窗口不足，减少丢包，避免浪费网络资源

流量控制的手段(点对点)：    
接收方窗口大小来控制  

一种特殊情况是，接收方窗口为0时怎么处理    
发送方开启一个定时器，隔一段时间发个测试报文去询问      


#### **二、拥塞控制**
为什么要进行拥塞控制？  
避免过多数据注入网络，避免路由和链路过载，丢包浪费网络资源     

拥塞控制的手段：    
慢开始、加法增大、乘法减小、快重传、快恢复       

<img src="/images/Network/tcp17.png" alt="img">

几个概念：    
MSS    
拥塞窗口、接收窗口、发送窗口     
超时重传和快重传是同时存在的：   
超时重传是发送方未在计时器时间内收到确认而进行的重传    
快重传是接收方收到不连续数据段后会发送3次相同的确认，发送方接收到3次确认后进行的重传     




<!-- ************************************************ -->
## <a id = "content10">10、TCP_序号、确认号</a>

#### **一、SYN、ACK、seq、ack** 

SYN=1:表示这是一个同步请求，在连接时有用     
ACK=1:表示确认号有效       
seq:相对序号，发送的数据的第一个字节的编号    
ack:确认号，告知对方我已经收到你ack-1个字节，请发送ack号开始的数据    

<span style="color:green;font-weight:bold">seq是对对方ack的回应<br>
ack是对对方seq的确认，<br>
ack从另一个角度理解是告诉对方目前已经收到了ack-1个字节</span>       

#### **二、数据分片和组装**
lxy:   
客户端发送http请求一个大文件         
服务器大块数据 -> 服务器应用层 -> 服务器传输层对数据分片(分片1， 分片2，...) -> .... -> 客户端传输层对数据组装(分片1， 分片2，...)大块数据 -> 客户端应用层     

从wearShark看：     
http:客户端的request请求    
tcp    
tcp    
tcp    
http:服务端的response响应    




<!-- ************************************************ -->
## <a id = "content11">11、连接、释放连接</a>

#### **一、连接**

三次握手及开始发送数据时      
序号和确认号极其标志位的变化      
客户端 SYN=1 ACK=0 seq=0 ack=0 len=0 发起连接请求        
服务端 SYN=1 ACK=1 seq=0 ack=1 len=0 同意建立连接       
客户端 SYN=0 ACK=1 seq=1 ack=1 len=0 我知道你同意了，下面我要开始发送数据了     
客户端 SYN=0 ACK=1 seq=1 ack=1 len=k     

握手阶段会交换：MSS/窗口大小/窗口缩放系数/初始序列号/是否支持选择确认        
握手的目的是为了交换信息，以便实现可靠传输、流量控制、拥塞控制     

为什么是三次握手的原因要明白      
服务器一旦进入连接状态就没有超时断开了，因为他要一直等客户端发数据过来    

TCP连接的四要素：源IP地址、源端口号、目标IP地址、目标端口号

#### **二、释放连接**

为什么是四次挥手

理解time-wait的作用

应用层可以关掉连接，TCP也可以关掉连接，但一般不用     
http的Keepalive和 TCP的Keepalive 不是一回事    

了解：closing状态 和 二三次挥手合并 的不同




<!-- ************************************************ -->
## <a id = "content12">12、应用层</a>

#### **一、域名**
为了方便记忆   
根域名 顶级域名 二级域名 三级域名   

#### **二、DNS协议(应用层)**
域名需要解析出ip地址    
DNS协议，DNS服务器   

域名申请的流程    

#### **三、DHCP协议(应用层)**     
ip地址的分配：静态分配和动态分配   

动态分配     
DHCP协议，DHCP服务器        
分配的四个阶段：发现服务器 - 提供租约 - 选择ip - 确认   

#### **四、几个思考问题**
1、为什么一个域名可以解析出多个ip地址？    
2、一个域名从无到注册到被使用经历了哪些步骤？   
3、DHCP究竟是怎么工作的？    
4、为什么通过ip地址能够获得地理位置？   
5、全球的ip地址是如何分配的？   
   


<!-- ************************************************ -->
## <a id = "content13">13、HTTP</a>

超文本：超出了文本本身的含义   

URI：统一资源标志符      
URL：统一资源定位符      

最常用的http版本是 1.1版本 1997年提出   


<!-- ************************************************ -->
## <a id = "content14">14、HTTP（二）</a>

#### **一、URL为什么需要编码**

一般对url编码，针对的是查询参数的key和value进行编码   
**1、最初设计是只支持ASCII码的，所以非ASCII码需要编码，比如中文**  
编码前：https://www.baidu.com/s?wd=百度
编码后：https://www.baidu.com/s?wd=%E5%8D%8E%E4%B8%BA    

**2、一些特殊字符（比如等号、空格），需要进行编码**    
编码前：https://www.baidu.com/s?wd=web develop   
编码后：https://www.baidu.com/s?wd=web%20develop   


#### **二、报文格式**
<img src="/images/Network/http1.png" alt="img">



<!-- ************************************************ -->
## <a id = "content15">15、HTTP（三）</a>

#### **一、常用请求方法**    
get、post       
put、delete       
head、option      

#### **二、请求头字段**

user-agent： 识别终端类型       
Reference：这个请求是由哪个请求带来的 防止盗链       
range:多线程断点下载       
Content-Type:  application/x-www-form-urlencoded  和 multipart/form-data(上传文件必须是这种+post)        
Accept: 能够接受的响应内容类型。text/plain 或者 text/html 或者 json     
Connection:keey-alive:想要优先使用的连接类型      
Cookie:使http的状态保留，比如存储sessionId    

请求头有标准头也有非标准头，维基百科搜索headers    

#### **三、响应头字段**   
Content-Type:text/html;charset=utf-8 与 请求头的Accept字段呼应    
Location:http://www.w3.org 用来重定向  
Connection:close 针对该连接预期的选项与请求头的Connection呼应      
Set-Cookie 与请求头的Cookie字段呼应

#### **四、状态码**
200：成功  

302：重定向,重定向是后台人员控制的    
304：就是服务器告诉客户端我这里没更新 你使用缓存就行.客户端一般会对HTML css静态资源进行缓存       

401：缺乏身份验证   
403：服务器有能力提供请求，但拒绝授权访问   
404：服务器端无法找到所请求的资源    

502：从上游服务器（如tomcat）中接收到的响应是无效的   
503：服务器停机维护或者已超载   

<span style="color:red;font-weight:bold">状态码后台人员是可以随意返回的</span>




<!-- ************************************************ -->
## <a id = "content16">16、HTTP（四）</a>

#### **一、同源策略**
协议 + 域名 + 端口 都相同就是同源    

前后端分离后，资源和资源内请求的url不是同源，那么就会存在跨域的问题  
相关的请求头字段：Origin  
相关的响应头字段：Access-Control-Allow-Origin    
跨域后不是服务器不返回数据，是浏览器不解析数据     

Ajex异步请求受同源策略影响

为什么img标签和css不受同源策略影响？    
异步请求受同源策略影响，一般来说，直接加载页面的 HTML、CSS、图像等静态资源不会受同源策略的限制。例如，使用 <img> 标签加载图像
xy:应为这些静态资源没有用户数据，所以不存在安全性问题。   
xy:即使是图片也是浏览器在解析，拿不到图片的数据。如果不是使用img标签，而是发请求要图片的二进制数据就会受同源策略的影响     


#### **二、cookie**  

为什么需要cookie？
http请求是无状态的,cookie可以是http请求有状态，比如登录状态        
token也是一种方案     

相关的请求头字段：Cookie  
相关的响应头字段：Set-cookie    

session   
<span style="color:red;font-weight:bold">Session是针对浏览器的，不是针对用户的</span>    
xy:小明的浏览器的cookie存储了sessionId,通过这个sessionId就可以找到服务器对应的Session    
xy:Session内存储了使用这台浏览器的用户比如mj,tom,...等的登录状态。
xy:session = creatSession(); session.add("mj",true);session.add("tom",true)




<!-- ************************************************ -->
## <a id = "content17">17、HTTP（五）</a>

代理服务器  

正向代理服务器：绕过防火墙、抓包工具Charles       

反向代理服务器：安全防护、负载均衡      

CDN:内容分发网络   


<!-- ************************************************ -->
## <a id = "content18">18、网络安全</a>

#### **一、安全威胁**   
ARP欺骗   
DoS攻击     
DNS劫持    

#### **二、加密算法**  

单向散列函数：MD5、SHA-1、SHA-2(SHA-256 SHA-512)、SHA-3

对称加密：DES、3DES、AES 块加密 模式

非对称加密：RSA    
公钥加密    
私钥签名    

混合密码系统的原理    

#### **三、证书**  

证书 = 公钥 + 签名  

CA机构   
浏览器和手机内，内置了CA机构的公钥,用于验证证书    




<!-- ************************************************ -->
## <a id = "content19">19、HTTPS</a>

#### **一、介绍**
安全套接层工作在应用层和传输层之间     
<span style="color:red;font-weight:bold;">所以TLS只会对应用层数据进行加密，传输层、网络层、链路层的头部信息都是明文的，并不会影响在路由器和链路上传播</span>  
① TCP的3次握手      
② TLS的连接      
③ HTTP请求和响应       
<img src="/images/Network/https3.png" alt="img">

#### **二、主要流程**

交换数据阶段：   
选择的加密组件比如：AES RSA ECDHE(一个秘钥生成算法)    
服务端随机数、服务端秘钥计算参数、服务端证书         
客户端随机数、客户端秘钥计算参数

验证阶段：    
利用交换的数据，生成加密秘钥：主密钥，子秘钥(客户端秘钥、服务端秘钥)    
服务器把之前通讯的全部报文加密发送给客户端，看客户端是否能正常解密     
客户端把之前通讯的全部报文加密发送给服务器，看服务器是否能正常解密     
如果都能解密成功握手结束，然后发送http报文     



<!-- ************************************************ -->
## <a id = "content20">20、HTTP的升级改进</a>


#### **一、http1.1的不足**   
同一时间，一个连接只能对应一个请求(同一连接不能并行发送请求)      
xy:原因是多个请求的数据同时发送无法被区分出来   

针对同一个域名，大多数浏览器允许同时最多6个并发连接   

请求应答模式，服务器不能主动给客户端发送消息 

头信息的重复传输     

#### **二、http2**   
只需要建立一个连接，可以并行发送请求（多路复用）     
xy:应为http2会标记数据属于哪个请求，到达之后会组装，所以支持多个请求同时发送    

头部信息压缩，客户端和服务器保存了相同的头部信息的表，如果头部字段的信息没有变，只发索引号就行     

服务器推送：对一个客户端的请求发送多个响应。只要连接不断，服务器可以随时向客户端发送数据   

存在的问题    
对头阻塞      
握手延迟    


#### **三、http3**

QUIC + UDP    
QUIC 解决对头阻塞、握手延迟、可靠传输等问题     

为什么不直接重新写一个传输层协议，而是在UDP的基础上再加一层QUIC？    
TCP和UDP涉及到操作系统内核是固化在操作系统内的    
现在的操作系统和网络设备，只认TCP和UDP    
写一个新的传输层协议，需要操作系统和网络设备的支持，协议替换成本太大导致无法实现        




<!-- ************************************************ -->
## <a id = "content21">21、其它协议</a>

#### **一、webSocket协议**

WebSocket和HTTP属于平级关系，都是应用层的协议   
WebSocket是应用层协议，Socket是一套网络编程API接口，两者是不同的  
WebSocket，是基于TCP的支持全双工通信的应用层协议     
WebSocket需要借助HTTP协议来建立连接（也叫作握手，Handshake），建立连接后客户端、服务器，任何一方都可以主动发消息给对方    
社交订阅、股票基金报价、体育实况更新、多媒体聊天、多玩家游戏等      

其实TCP本身就是支持全双工通信的（客户端、服务器均可主动发消息给对方）只是HTTP的“请求-应答模式”限制了TCP的能力    


#### **二、HTTPDNS**

HTTPDNS是基于HTTP协议向DNS服务器发送域名解析请求   


<!-- ************************************************ -->
## <a id = "content22">22、补充</a>

#### **一、vpn**

vpn客户端 + vpn服务端  + 隧道协议

隧道协议工作在传输层    

作用   
1、提高上网的安全性    
2、保护公司内部资料    
3、隐藏上网者的身份     
4、突破网站的地域限制   
5、突破网络封锁   

访问公司内网（通过vpn技术，将自己作为公司内网的一个成员）  

隐藏用户的ip地址  





#### **二、缓存**

<img src="/images/Network/buchong7.png" alt="img">

#### **三、IPv6**

用它来取代IPv4主要是为了解决IPv4地址枯竭问题，同时它也在其他方面对于IPv4有许多改进    

主要的头信息：源IP地址 和 目标IP地址 还是都有的  















----------
>  行者常至，为者常成！


