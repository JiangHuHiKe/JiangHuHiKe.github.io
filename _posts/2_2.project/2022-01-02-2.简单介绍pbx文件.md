---
layout: post
title: "2.简单介绍pbx文件"
date: 2022-01-02
tag: 工程化
---



## 目录
- [几个常用的操作](#content1)   
- [pbxproj文件](#content2)   
- [操作pbxproj](#content3)   



<!-- ************************************************ -->
## <a id="content1">几个常用的操作</a>

#### **一、修改产物路径**
一个workspace下，两个project，project下的target名称都叫LCCat<br>
那么这两个构建产物放在同一个目录下是会报错的<br>
参考cocoapods的脚本文件(/XYApp/Pods/Target Support Files/Pods-XYApp/Pods-XYApp.debug.xcconfig)，将产物输出到指定的路径<br>

修改产物的存放位置，在xx.xcconfig文件中配置：
```shell
# CONFIGURATION_BUILD_DIR 为构建产物的存放位置
CONFIGURATION_BUILD_DIR = ${SRCROOT}/${PROJECT_NAME}
```

#### **二、引用其它shell的环境变量**
xcconfig文件中的内容
```shell
HMAP_PATH="aa" "bb" "cc"

TTY=/dev/ttys002

# source ~/.zshrc 加载Zsh Shell的配置文件 .zshrc 到当前Shell环境中
# 因为zsh和xcode的shell不是同一shell,想要在xcode中使用zsh的环境便令需要进行加载
# ;用于隔离指令和隔离语句
# 空格隔离的字符串可以用for来遍历
CMD= source ~/.zshrc; git status; for i in $HMAP_PATH; do echo $i;done
```

Run Script中的内容
```shell
if [[ -n $TTY ]]; then
    eval $CMD &> $TTY
    echo $? &> $TTY
fi
```

#### **三、自制命令行工具**
**1、代码如下**
```c
// argc：参数个数
// argv：传递的参数
// char** env 也是一个数组，环境变量
// 在xcode中llvm可以使用 parray n argv 来调试数组。n：表示输出几个元素
int main(int argc, const char * argv[], char** env) {
    if (argc < 2) {
      fprintf(stderr, "%s\n", "请输入参数，或者输入--help查看可用参数");
      return EX_USAGE;
    }
    while (*env){
        printf("%s\n", *env++);
    }
    // 获取配置的环境变量
    char *cat = getenv("LG_CAT_ENV");
    return 0;
}
```
<img src="/images/project/10.png">

**2、制作命令行工具**

在工程的根目录下执行
```shell
# 显示所有的配置项(环境变量)
xcodebuild -showBuildSettings

# 找到Build_DIR,这就是存放构建产物的露露
BUILD_DIR = /Users/lxy/Library/Developer/Xcode/DerivedData/LGCat-gnpihysabhvurnglqyzuklcmosdi/Build/Products

# 打开目录将产物移动的 /usr/local/bin目录下
mv LGCat /usr/local/bin/
```

**3、使用命令行工具**
```shell
22:37:59 › which LGCat
/usr/local/bin/LGCat

22:40:21 › file /usr/local/bin/LGCat
/usr/local/bin/LGCat: Mach-O 64-bit executable arm64

22:40:31 › LGCat
请输入参数，或者输入--help查看可用参数

22:40:40 › LGCat --help
CA_DEBUG_TRANSACTIONS=1
TERM_PROGRAM=Apple_Terminal
SHELL=/bin/zsh
...
```


<!-- ************************************************ -->
## <a id="content2">pbxproj文件</a>

**一、pbxproj文件格式**
```shell
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 55;
	objects = {
		32D0E7200A98E65B5000E84E /* Products */ = {
			isa = PBXGroup;
			children = (
			);
			name = Products;
			sourceTree = "<group>";
		};

		54D3C6EA28804C9F009003C3 = {
			isa = PBXGroup;
			children = (
				32D0E7200A98E65B5000E84E /* Products */,
				EC38E118B4FEFAF22398A45F /* LGCat.h */,
			);
			sourceTree = "<group>";
		};
	};
	rootObject = 54D3C6EB28804C9F009003C3 /* Project object */;
}
```
**最外层的数据格式是**<br>
archiveVersion:当前文件的生成版本<br>
objectVersion:当前文件内 objects的描述版本<br>
classes:占位，没有实际意义<br>
objects:字典，以每个object的UUID作为key，object的属性作为value<br>
rootObject:当前文件的根object的UUID(isa = PBXProject)<br>


**二、文件内key的介绍**

每个object是一个字典<br>
每个object都有一个isa key，用来表明当前是什么object<br>
每个object也有很多attributes key，用来表明当前object特性。以及包含的其他 object的UUID，描述object的依赖和包含关系<br>

**1、已知的object:**
```shell
PBXBuildFile AbstractBuildPhase PBXBuildRule XCBuildConfiguration XCConfigurationList
逻辑教育Cat
PBXContainerItemProxy:用来代指当前project包含的其他project
PBXFileReference PBXGroup
PBXProject PBXTargetDependency
PBXReferenceProxy?:当前project引用的，相同空间的其他project的文 件
AbstractTarget
```

**2、已知的AbstractTarget:**
```shell
PBXNativeTarget:正常 
PBXAggregateTarget:代表一组文件，占位target 
PBXLegacyTarget:使用外部构建工具的生成的target
```

**3、已知的 PBXGroup:**
```shell
XCVersionGroup:包含多个不同版本的文件( CoreData) 
PBXVariantGroup:本地化文件
```

**4、已知的 PBXGrAbstractBuildPhase:**
```shell
PBXCopyFilesBuildPhase
PBXResourcesBuildPhase 
PBXSourcesBuildPhase 
PBXFrameworksBuildPhase 
PBXHeadersBuildPhase 
PBXShellScriptBuildPhase
```

**5、sourceTree:**
```shell
<absolute>:绝对路径 
<group>:相对于所在group路径 
SOURCE_ROOT:相对于工程所在目录路径 
DEVELOPER_DIR:相对于DEVELOPER_DIR目录路径 
BUILT_PRODUCTS_DIR:相对于产物所在目录路径 
SDKROOT:相对于SDK目录所在路径
```


<!-- ************************************************ -->
## <a id="content3">操作pbxproj</a>

**一、操作文件的方式**

xcodeproj提供的API接口

cocoapods的命令行工具：xcodeproj

xcode的内置工具：

**二、一个演示**

<img src="/images/project/11.png">

在podfile文件内编写下面内容，执行pod install 会将LGCat.h文件引用到工程中
```ruby
# workspace函数 参数
workspace './LGWorkspace.xcworkspace'
p 'Cat----'

#引用模块
# ruby 执行环境内置变量$LOAD_PATH
#这个模块是怎么找到的，内置变量$LOAD_PATH拼接上模块名
require 'xcodeproj'

app_project_path = './LGProject.xcodeproj'
project = Xcodeproj::Project.open(app_project_path)

file_path = './LGCat.h'
project.new_file(file_path)
project.save
```


----------
>  行者常至，为者常成！


