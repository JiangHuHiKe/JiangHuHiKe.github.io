---
layout: post
title: "【进阶】24、速览(数据结构与算法二)"
date: 2020-04-23
description: ""
tag: 数据结构与算法
---






## 目录

* [【进阶】1、排序](#content1)
* [【进阶】2、排序（二）](#content2)
* [【进阶】3、排序（三）](#content3)
* [【进阶】4、排序（四）](#content4)
* [【进阶】5、排序（五）](#content5)



```
* [](#content)
<!-- ************************************************ -->
## <a id="content"></a>
```



<!-- ************************************************ -->
## <a id="content1">【进阶】1、排序</a>

```
初识排序
    十大排序算法
        选择排序
            冒泡,选择,堆排序,插入,归并,快速,希尔

        其它排序
            计数排序,基数排序,桶排序
```


```
冒泡排序（Bubble Sort）
    执行流程（统一以升序为例子）
        1.从头开始比较每一对相邻元素，如果第1个比第2个大，就交换它们的位置
            执行完一轮后，最末尾那个元素就是最大的元素

        2.忽略 1 中曾经找到的最大元素，重复执行步骤1，直到全部元素有序

    优化1
        记录是否有发生交换,没有发生交换证明已经排序好

    优化2
        记录最后一次发生交换的索引,索引及之后的数据已经排序好,不需要再次进行判断及交换

排序算法的稳定性（Stability）
    相同元素,排序前后的相对位置没有发生变化,就是稳定的排序算法

原地算法（In-place Algorithm）
    空间复杂度为 𝑂(1) 的都可以认为是原地算法
```


```
选择排序（Selection Sort）
    执行流程
        ① 从序列中找出最大的那个元素，然后与最末尾的元素交换位置
            ✓ 执行完一轮后，最末尾的那个元素就是最大的元素
        ② 忽略 ① 中曾经找到的最大元素，重复执行步骤 ①
```


```
堆排序（Heap Sort）
    堆排序可以认为是对选择排序的一种优化

    执行流程
        ① 对序列进行原地建堆（heapify）
        
        ② 重复执行以下操作，直到堆的元素数量为1
            ✓ 交换堆顶元素与尾元素
            ✓ 堆的元素数量减 1
            ✓ 对 0 位置进行 1 次 siftDown 操作
```



<!-- ************************************************ -->
## <a id="content2">【进阶】2、排序（二）</a>

```
插入排序（Insertion Sort）
    执行流程
        ① 在执行过程中，插入排序会将序列分为2部分
            ✓ 头部是已经排好序的，尾部是待排序的

        ② 从头开始扫描每一个元素
            ✓ 每当扫描到一个元素，就将它插入到头部合适的位置，使得头部数据依然保持有序

    插入排序-优化
        思路是将【交换】转为【挪动】
            ① 先将待插入的元素备份
            ② 头部有序数据中比待插入元素大的，都朝尾部方向挪动1个位置
            ③ 将待插入元素放到最终的合适位置
```


```
二分搜索（Binary Search）
    [begin end)
    mid = (begin + end)/2

    [begin mid)
    [mid+1 end)
```

```
插入排序优化
    在元素 v 的插入过程中，可以先二分搜索出合适的插入位置，然后再将元素 v 插入
    需要注意的是，使用了二分搜索后，只是减少了比较次数，但插入排序的平均时间复杂度依然是 O(n^2)
```


<!-- ************************************************ -->
## <a id="content3">【进阶】3、排序（三）</a>

```
归并排序（Merge Sort）
    divide
        ① 不断地将当前序列平均分割成2个子序列
        ✓ 直到不能再分割（序列中只剩1个元素）

    merge
        ② 不断地将2个子序列合并成一个有序序列
        ✓ 直到最终只剩下1个有序序列
```


```
归并排序原理
-(void)sort{
    [self sortWithBegin:0 end:(int)self.array.count];
}


/// 归并排序divide实现 [begin end) 左闭右开
/// @param begin 起始索引
/// @param end 终止索引
-(void)sortWithBegin:(int)begin end:(int)end{
    //至少要2个元素
    if(end - begin <2) return;
    int mid = (begin+end)>>1;
    
    //拆分左半部分
    [self sortWithBegin:begin end:mid];
    
    //拆分右半部分
    [self sortWithBegin:mid end:end];
    
    //合并左右两部分
    [self mergeWithBegin:begin mid:mid end:end];
}
```


```
归并排序实现


复杂度分析
    所以最好、最坏、平均时间复杂度都是 O(nlogn) ，属于稳定排序
    归并排序的空间复杂度是 O n/2 + logn = O(n)
        n/2 用于临时存放左侧数组，logn 是因为递归调用
```


<!-- ************************************************ -->
## <a id="content4">【进阶】4、排序（四）</a>

```
快速排序（Quick Sort）
    快速排序 – 执行流程

        ① 从序列中选择一个轴点元素（pivot）
        ✓ 假设每次选择 0 位置的元素为轴点元素

        ② 利用 pivot 将序列分割成 2 个子序列
        ✓ 将小于 pivot 的元素放在pivot前面（左侧）
        ✓ 将大于 pivot 的元素放在pivot后面（右侧）
        ✓ 等于pivot的元素放哪边都可以

        ③ 对子序列进行 ① ② 操作
        ✓ 直到不能再分割（子序列中只剩下1个元素）

    快速排序的本质
        逐渐将每一个元素都转换成轴点元素

```

```
快速排序的实现
/**
 最好、平均时间复杂度：O(nlogn) 最坏时间复杂度：O(n2)
 由于递归调用的缘故，空间复杂度：O(logn)
 */
-(void)sort{
    
    [self sortWithBegin:0 end:(int)self.array.count];
}



/// 快速排序[beigin end)
/// @param begin 起始index
/// @param end 结束index
-(void)sortWithBegin:(int)begin end:(int)end{
    
    //至少需要两个元素
    if(end - begin<2) return;
    
    //找到轴点元素的位置
    int mid = [self pivotIndexWithBegin:begin end:end];
    
    
    //对左半部分进行快速排序
    [self sortWithBegin:begin end:mid];
    
    
    //对有半部分进行快速排序
    [self sortWithBegin:mid+1 end:end];
    
}




/// 返回轴点元素索引[begin end)
/// @param begin 起始索引
/// @param end 终止索引
-(int)pivotIndexWithBegin:(int)begin end:(int)end{
    
    //为了降低最坏情况的出现概率，一般采取的做法是 随机选择轴点元素
    int randomIndex = begin+ random()%(end - begin);//[begin end)
    [self swapWithIndex1:begin index2:randomIndex];
    
    //备份pivot元素
    id pivot = self.array[begin];
    
    //因为是左闭右开所以end--;
    end--;

    //当begin = end时，结束
    while (begin<end) {
        
        
        while(begin<end){
            //末尾元素大于pivot，end-- 思考：可以将条件改为 <=0 吗？ 不可以
            if ([self compareWithValue1:pivot value2:self.array[end]] < 0) {
                end--;
                
            //末尾元素小于等于pivot,进行交换 begin++
            }else{
                //self.array[begin] = self.array[end];
                [self moveWithFromIndex:end toIndex:begin];
                begin++;
                
                //结束，进入轮换
                break;
            }
        }
        
        
        while(begin<end){
            //起始元素小于末尾元素，begin++ 思考：可以将条件改为 >=0 吗？ 不可以
            if ([self compareWithValue1:pivot value2:self.array[begin]] > 0) {
                begin++;
                
            //起始元素大于等于末尾元素，进行交换，end--
            }else{
                //self.array[end] = self.array[begin];
                [self moveWithFromIndex:begin toIndex:end];
                end--;
                
                //结束，进入轮换
                break;
            }
        }
    }
    
    //放置轴点元素
    self.array[begin] = pivot;
    
    //执行到此处begin == end 返回begin或end都可以。该位置就是pivot的索引
    return begin;
}
```


```
希尔排序（Shell Sort）
    希尔排序的效率取决于步长
    希尔本人给出的步长序列是 𝑛/2^𝑘，比如 𝑛 为16时，步长序列是{1, 2, 4, 8}
```


<!-- ************************************************ -->
## <a id="content5">【进阶】5、排序（五）</a>

```
计数排序（Counting Sort）
    创建一个数组
    数组索引就是要排序的数字
    统计数字出现的次数
    按出现的次数依次写出数字就完成了排序

基数排序（Radix Sort）
    先按个位进行排序
    再按十位进行排序
    再按百位进行排序

桶排序（Bucket Sort）


```




----------
>  行者常至，为者常成！


