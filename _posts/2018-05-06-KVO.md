---
layout: post
title: "KVO"
date: 2018-05-06
description: "NSObject的本质"
tag: 底层原理
---


<h6>
  版权声明：本文为博主原创文章，未经博主允许不得转载。
  <a target="_blank" href="https://jianghuhike.github.io/1856.html">
  原文地址：https://jianghuhike.github.io/1856.html 
  </a>
</h6>


- [参考文章：OC源码分析之对象的创建](https://juejin.im/post/5de08bf85188254fc26bc242)
- [参考文章：Alloc 和 AllocWithZone 区别和联系](https://www.jianshu.com/p/e40417fa3fad)


## 目录


- [基本使用](#content1)   
- [分析](#content2)   
- [alloc与allocWithZone](#content3) 



<!-- ************************************************ -->
## <a id="content1"></a>基本使用
KVO的全称是Key-Value Observing,俗称键值监听，可以用于监听某个对象属性值的改变。

创建一个Person类
```objc
@interface Person : NSObject
@property (assign, nonatomic) int age;
@end
```
使用案例
```objc
#import "ViewController.h"
#import "Person.h"

@interface ViewController ()
@property (nonatomic, strong) Person * person1;//
@property (nonatomic, strong) Person * person2;//
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    self.person1 = [[Person alloc] init];
    self.person1.age = 1;
    
    self.person2 = [[Person alloc] init];
    self.person2.age = 2;
    
    NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;
    [self.person1 addObserver:self forKeyPath:@"age" options:(options) context:@"123"];
}

-(void)observeValueForKeyPath:(NSString *)keyPath
                     ofObject:(id)object
                       change:(NSDictionary<NSKeyValueChangeKey,id> *)change
                      context:(void *)context{
    
    NSLog(@"object=%@",object);
    NSLog(@"change=%@",change);
    NSLog(@"context=%@",context);
}


-(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
    self.person1.age = 10;
    self.person2.age = 20;
}

-(void)dealloc{
    //一定要移除监听，否则引起内存泄漏
    [self.person1 removeObserver:self forKeyPath:@"age"];
}
@end
```

每次点击屏幕的打印日志为

```objc
object=<Person: 0x13565c030>
change={
    kind = 1;
    new = 10;
    old = 2;
}
context=123
```

<!-- ************************************************ -->
## <a id="content2"></a>分析
如上面的例子，我们在添加监听前打个断点，添加监听后打个断点，来看看person1和person2发生了什么变化。      
```objc
//添加监听前：lldb调试
(lldb) po self.person1->isa
Person

(lldb) po self.person2->isa
Person

//添加监听后：lldb调试
(lldb) po self.person1->isa
NSKVONotifying_Person

(lldb) po self.person2->isa
Person
```
可以看出添加了监听的person1的isa指针的指向发生了变化。产生了一个新的类对象，NSKVONotifying_Person。   
   
我们来分析下person1->isa指向的类对象，在添加监听前后发生了什么变化?

封装一个打印对象方法名的方法
```objc
- (void)printMethodNamesOfClass:(Class)cls{
    unsigned int count;
    //获得方法列表
    Method * methodList = class_copyMethodList(cls, &count);
    
    //遍历方法列表
    for (int i=0; i<count; i++) {
        //获得方法
        Method method = methodList[i];
        
        //获得方法名
        SEL nameSel = method_getName(method);
        NSString * methodName =NSStringFromSelector(nameSel);
        NSLog(@"methodName-%d=%@",i,methodName);
    }
}
```
在监听前后分别调用该方法
```objc
//监听前
[self printMethodNamesOfClass:object_getClass(self.person1)];
//methodName-0=setAge:
//methodName-1=age


//监听后
[self printMethodNamesOfClass:object_getClass(self.person1)];
//methodName-0=setAge:
//methodName-1=class
//methodName-2=dealloc
//methodName-3=_isKVOA
```

通过以上分析可知：

|(监听前)perosn1->isa 指向 Person类对象|(监听后)person1->isa 指向 NSKVONotifying_Person类对象|
|setAge: |setAge:|
| age    |class|
|        |dealloc|
|        |_isKVOA|




----------
>  行者常至，为者常成！


