---
layout: post
title: "动静态库"
date: 2020-07-01
tag: 工程化
---


## 目录
- [静态库](#content1)   
- [动态库](#content2)   


-[iOS静态库和动态库详解](https://juejin.cn/post/7237661384996569125)
-[iOS之深入解析静态库和动态库](https://blog.csdn.net/Forever_wj/article/details/120018386)


## <a id="content1">静态库</a>

.o文件的合集，是编译后的产物，在链接阶段会被打包进mach-O可执行文件     


## <a id="content2">动态库</a>

是多个.o文件，链接后的产物，不会被打包进mach-O可执行文件，只会把引用打包进mach-o(rPath/frameworks/xxxx.framework)

在app启动时根据引用通过dyld加载进内存，所以过多的动态库会影响app的启动时间  


静态库可以依赖静态库（一块打包进了mach-o）         
静态库可以依赖动态库（相当于app依赖动态库，应为静态库在链接阶段已经被打包进了mach-o）        
动态库可以依赖动态库 (动态库内记录了另外一个动态库的引用)          
动态库不能依赖静态库! (lxy：动态库a依赖静态库a，动态库b依赖静态库a，动态库在链接阶段就会将静态库a打包进去，所以多个动态库依赖相同的静态库，会存在多分静态库的代码)     

**为什么动态库不能动态加载**   

在 iOS app 启动时系统会查找我们所依赖的所有动态库并加载, 这降低了我们 App 的启动速度, 那么可不可以将动态库的调用时间延迟到 app 运行时?     
答案是不能!      

不能动态加载动态库的原因是iOS系统的限制. 

查看苹果的 API 文档, 会发现有一个方法提供了加载可执行文件的功能,那就是 NSBundle 的 load 方法 (底层实现为 dlopen 函数)             

1、iOS 出于安全考虑, 在加载可执行代码前, 需要校验签名    

2、load 方法的内部实现是调用了 dlopen, 而真机的 dlopen 内部还会调用dlopen_preflight 先校验签名.      
如果库不是事先打包进 app(打包进 app 的话会与 app 有相同签名), 就会报签名错误(Signature error), 从而加载不成功.    

3、因此动态加载库在模拟器上可以实现, 但是真机上不能运行    

所有目前只能在 Mac OS 上使用. 如果以后系统放开签名校验, 那么 iOS 中也就可以动态加载了





----------
>  行者常至，为者常成！


